{
  "posts": [
    {
      "content": "问题发现：http://404j.fun/post/vue-yi-dian-yi-huo/\r\nvue官方建议：https://vuejs.org/v2/style-guide/#Self-closing-components-strongly-recommended\r\n对于Dom模板和字符串模板的解释：https://forum.vuejs.org/t/confused-about-dom-template-and-string-template/1797\r\nvue issue:https://github.com/vuejs/vue/issues/1036\r\nDom模板如何工作：https://stackoverflow.com/questions/56941466/vue-component-not-mounting-or-rendering-and-no-error-messages/56941500\r\n为啥尽量避免Dom模板而用字符串模板：https://vuejsdevelopers.com/2017/09/17/vue-js-avoid-dom-templates/\r\n\r\n\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"app\">\r\n        <my-component></my-component>\r\n        <!-- <my-component /> -->\r\n        能看到我吗？\r\n    </div>\r\n</body>\r\n<script>\r\n    let MyComponent = {\r\n        template: `\r\n            <div>my test component</div>\r\n        `\r\n    } \r\n    const app = new Vue({\r\n        el: '#app',\r\n        components: {\r\n            'my-component': MyComponent\r\n        }\r\n    })\r\n</script>\r\n\r\n</html>\r\n```",
      "data": {
        "title": "Vue: 一点疑惑",
        "date": "2020-05-19 10:19:54",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vue-yi-dian-yi-huo"
    },
    {
      "content": "基本涵盖了在开发中用到的git命令，能满足日常需求。\r\n\r\n[原Repo🌌](https://github.com/xjh22222228/git-manual)\r\n---\r\n\r\n## 配置\r\n```bash\r\n# 查看全局配置列表\r\ngit config -l\r\n# 查看局部配置列表\r\ngit config --local --list\r\n\r\n# 查看已设置的全局用户名/邮箱\r\ngit config --global --get user.name\r\ngit config --global --get user.email\r\n\r\n# 设置全局用户名/邮箱\r\ngit config --global user.name \"xiejiahe\"\r\ngit config --global user.email \"example@example.com\"\r\n\r\n# 设置本地当前工作区仓库用户名/邮箱\r\ngit config --local user.name \"xiejiahe\"\r\ngit config --local user.email \"example@example.com\"\r\n\r\n# 删除配置\r\ngit config --unset --global user.name\r\ngit config --unset --global user.email\r\n\r\n# 将默认文本编辑器设置为 emacs\r\ngit config --global core.editor emacs\r\n\r\n# 将默认差异化分析工具设置为 vimdiff\r\ngit config --global merge.tool vimdiff\r\n```\r\n\r\n\r\n\r\n## 生成SSH_Key\r\n```bash\r\n# 1、粘贴以下命令，替换为您的GitHub电子邮件地址\r\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\r\n\r\n# 2、当提示“输入要在其中保存密钥的文件”时，按Enter。接受默认文件位置。\r\n> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]\r\n\r\n# 3、在提示符下，键入一个安全密码。\r\n> Enter passphrase (empty for no passphrase): [Type a passphrase]\r\n> Enter same passphrase again: [Type passphrase again]\r\n```\r\n\r\n最后需要将生成的 SSH Key 添加到 `ssh config` 中\r\n```bash\r\n# 1、编辑\r\nvim ~/.ssh/config\r\n\r\n# 2、粘贴下面到 config 文件中\r\nHost *\r\n  AddKeysToAgent yes\r\n  UseKeychain yes\r\n  IdentityFile ~/.ssh/id_rsa\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 初始化仓库\r\n`git init` 创建一个空的Git仓库或重新初始化一个现有的仓库\r\n```bash\r\n# 会在当前目录生成.git\r\ngit init\r\n\r\n# 以安静模式创建，只会打印错误或警告信息\r\ngit init -q\r\n\r\n# 创建一个裸仓库, 通常情况下用不上\r\ngit init --bare\r\n```\r\n\r\n## 文件状态\r\n```bash\r\n# 完整查看文件状态\r\ngit status\r\n\r\n# 以短格式给出输出\r\ngit status -s\r\n\r\n# 忽略子模块\r\ngit status --ignore-submodules\r\n```\r\n\r\n## 日志\r\n```bash\r\n# 查看完整历史提交记录\r\ngit log\r\n\r\n# 查看前N次提交记录 commit message\r\ngit log -2\r\n\r\n# 查看前N次提交记录，包括diff\r\ngit log -p -2\r\n\r\n# 搜索关键词\r\ngit log -S Java\r\n\r\n# 只显示合并日志\r\ngit log --merges\r\n\r\n# 以图形查看日志记录, --oneline 可选\r\ngit log --graph --oneline\r\n\r\n# 列出提交者贡献数量, 只会打印作者和贡献数量\r\ngit shortlog -sn\r\n\r\n# 以提交贡献数量排序并打印出message\r\ngit shortlog -n\r\n\r\n# 采用邮箱格式化的方式进行查看贡献度\r\ngit shortlog -e\r\n\r\n# 查看 README.md 文件的修改历史记录，包括时间、作者以及内容\r\ngit blame README.md\r\n```\r\n\r\n\r\n## 克隆\r\n```bash\r\n# https 协议\r\ngit clone https://github.com/xjh22222228/git-manual.git\r\n\r\n# SSH协议\r\ngit clone git@github.com:xjh22222228/git-manual.git\r\n\r\n# 克隆某个分支， -b 指定分支名字\r\ngit clone -b master https://github.com/xjh22222228/git-manual.git\r\n\r\n# 递归克隆，如果项目包含子模块就非常有用\r\ngit clone --recursive git@github.com:xjh22222228/git-manual.git\r\n\r\n# 克隆深度为1, 不会把历史的记录也克隆，这样可以节省克隆时间\r\ngit clone --depth=1 https://github.com/xjh22222228/git-manual.git\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n\r\n## 查看分支\r\n```bash\r\n# 查看所有分支\r\ngit branch -a\r\n\r\n# 查看本地分支\r\ngit branch\r\n\r\n# 查看远端分支\r\ngit branch -r\r\n\r\n# 查看本地分支所关联的远程分支\r\ngit branch -vv\r\n\r\n# 查看本地 master 分支创建时间\r\ngit reflog show --date=iso master\r\n```\r\n\r\n## 切换分支\r\n```bash\r\n# 2种方法，切换到master分支\r\ngit checkout master\r\ngit switch master\r\n\r\n# 切换上一个分支\r\ngit checkout -\r\n\r\n# 切换远端分支\r\ngit checkout -t origin/dev\r\n```\r\n\r\n## 创建分支\r\n```bash\r\n# 创建develop本地分支\r\ngit branch develop\r\n\r\n# 创建本地develop分支并切换\r\ngit checkout -b develop\r\n\r\n# 创建远程分支, 实际上创建本地分支然后推送\r\ngit checkout -b develop\r\ngit push origin develop\r\n\r\n\r\n# 创建一个空的分支, 不继承父分支，历史记录是空的，一般至少需要执行4步\r\ngit checkout --orphan develop\r\n# 这一步可选，如果你真的想创建一个没有任何文件的分支\r\ngit rm -rf .\r\n# 添加并提交，否则分支是隐藏的 （执行这一步之前需要注意当前工作区必须保留一个文件，否则无法提交）\r\ngit add -A && git commit -m \"提交\"\r\n# 推送到远程\r\ngit push --set-upstream origin develop\r\n```\r\n\r\n\r\n## 删除分支\r\n```bash\r\n# 删除本地分支\r\ngit branch -d <branchName>\r\n\r\n# 删除远程分支\r\ngit push origin :<branchName>\r\n```\r\n\r\n## 重命名分支\r\n```bash\r\n# 重命名当前分支, 通常情况下需要执行3步\r\n# 1、修改分支名称\r\n# 2、删除远程旧分支\r\n# 3、将重命名分支推送到远程\r\ngit branch -m <branchName>\r\ngit push origin :old_branch\r\ngit push -u origin new_branch\r\n\r\n\r\n# 重命名指定分支\r\ngit branch -m old_branch new_branch\r\n```\r\n\r\n----\r\n\r\n\r\n## 代码合并\r\n```bash\r\n# 两步法, 将 feature/v1.0.0 分支代码合并到 develop\r\ngit checkout develop\r\ngit merge feature/v1.0.0\r\n\r\n# 或者一步法\r\ngit merge feature/v1.0.0 develop\r\n\r\n# 以安静模式合并, 把develop分支合并到当前分支并不输出任何信息\r\ngit merge develop -q\r\n\r\n# 合并不编辑消息, 跳过交互\r\ngit merge develop --no-edit\r\n```\r\n\r\n\r\n\r\n## 暂存\r\n```bash\r\n# 暂存所有\r\ngit add -A\r\n\r\n# 暂存某个文件\r\ngit add ./README.md\r\n\r\n# 暂存当前目录所有改动文件\r\ngit add .\r\n\r\n# 暂存一系列文件\r\ngit add 1.txt 2.txt ...\r\n```\r\n\r\n## 删除\r\ngit add 的反向操作\r\n```bash\r\n# 删除1.txt 文件\r\ngit rm 1.txt\r\n\r\n# 删除当前所有文件, 与rm -rf 命令不同的是不会删除 .git 目录\r\ngit rm -rf .\r\n\r\n# 清除当前工作区缓存，但不会删除文件，通常用于修改文件名不生效问题\r\ngit rm -r --cached .\r\n```\r\n\r\n## 提交\r\n```bash\r\n# -m 提交的信息\r\ngit commit -m \"changes log\"\r\n\r\n# 只提交某个文件\r\ngit commit README.md -m \"message\"\r\n\r\n# 提交并显示diff变化\r\ngit commit -v\r\n\r\n# 允许提交空消息，通常必须指定 -m 参数\r\ngit commit --allow-empty-message\r\n\r\n# 重写上一次提交信息，确保当前工作区没有改动\r\ngit commit --amend -m \"新的提交信息\"\r\n```\r\n\r\n## 推送\r\n```bash\r\n# 推送内容到主分支\r\ngit push -u origin master\r\n\r\n# 本地分支推送到远程， 本地分支:远程分支\r\ngit push origin <branchName>:<branchName>\r\n\r\n# 简写，默认推送当前分支\r\ngit push\r\n\r\n# 强制推送, -f 是 --force 缩写\r\ngit push -f\r\n```\r\n\r\n----\r\n\r\n\r\n## 拉取最新内容\r\n```bash\r\n# 推荐，因为不会做自动合并\r\ngit fetch origin master\r\n\r\n# 相当于git fetch 然后 git merge\r\ngit pull\r\n\r\n# 后面的意思是： 远程分支名:本地分支名\r\ngit pull origin master:master\r\n\r\n# 如果是要与本地当前分支合并，则冒号后面的<本地分支名>可以不写\r\ngit pull origin master\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n## 查看文件的改动\r\n```bash\r\n# 查看所有文件改动\r\ngit diff\r\n\r\n# 查看具体文件的改动\r\ngit diff README.md\r\n\r\n# 查看某个版本的改动, 后面那一窜是commitId， git log后就能看到\r\ngit diff d68a1ef2407283516e8e4cb675b434505e39dc54\r\n\r\n# 查看某个文件的历史修改记录\r\ngit log README.md\r\ngit show d68a1ef2407283516e8e4cb675b434505e39dc54 README.md\r\n```\r\n\r\n----\r\n\r\n## 回滚版本\r\n```bash\r\n# 回滚上一个版本\r\ngit reset --hard HEAD^\r\n\r\n# 回滚上两个版本\r\ngit reset --hard HEAD^^\r\n\r\n# 回退到指定版本，git log 就能看到commit id了\r\ngit reset --hard 'commit id'\r\n\r\n# 回滚版本是不保存在 git log，如果想查看使用\r\ngit reflog\r\n```\r\n\r\n----\r\n\r\n## 撤销\r\n```bash\r\n# 撤销当前目录下所有文件的改动\r\ngit checkout -- .\r\n\r\n# 撤销指定文件修改\r\ngit checkout -- README.md\r\n\r\n# 暂存区回到工作区, 指定 ./README.md 文件从暂存区回到工作区\r\ngit reset HEAD ./README.md\r\n\r\n# 撤销commit, 回到工作区, 一般commit id 是前一个\r\ngit reset <commit_id>\r\n\r\n# 撤销commit, 并且把修改同时撤销\r\ngit reset --hard <commit_id>\r\n```\r\n\r\n\r\n\r\n## 标签\r\n```bash\r\n# 列出本地所有标签\r\ngit tag\r\n\r\n# 列出远程所有标签\r\ngit ls-remote --tags origin\r\n\r\n# 按照特定模式查找标签, `*` 模板搜索\r\ngit tag -l \"v1.0.0*\"\r\n\r\n# 创建带有附注标签\r\ngit tag -a v1.1.0 -m \"标签描述\"\r\n\r\n# 创建轻量标签, 不需要带任何参数\r\ngit tag v1.1.0\r\n\r\n# 后期打标签, 假设之前忘记打标签了，可以通过git log查看commit id\r\ngit log\r\ngit tag -a v1.1.0 <commit_id>\r\n\r\n# 推送到远程，默认只是本地创建\r\ngit push origin v1.1.0\r\n\r\n# 一次性推送所有标签到远程\r\ngit push origin --tags\r\n\r\n# 删除标签, 你需要再次运行 git push origin v1.1.0 才能删除远程标签\r\ngit tag -d v1.1.0\r\n\r\n# 删除远程标签\r\ngit push origin --delete v1.1.0\r\n\r\n# 检查标签\r\ngit checkout v1.1.0\r\n\r\n# 查看本地某个标签详细信息\r\ngit show v1.1.0\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Rebase\r\n`git rebase` 主要作用可以将多个commit记录合并为一条\r\n```bash\r\n# 操作最近4次提交\r\ngit rebase -i HEAD~4\r\n# 或者以 commit_id 进行操作\r\ngit rebase -i e88835de905ad396f61a0dc8c040a8ac8a34f3f8\r\n\r\n\r\n# 放弃 git rebase 操作\r\ngit rebase --abort\r\n\r\n# 此命令主要用于解决冲突后继续执行\r\ngit rebase --continue\r\n```\r\n\r\n参考：[git rebase将多次commit合并为一条](https://www.xiejiahe.com/blog/detail/5d550e8553d11b2c3ca05cbe)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## GitFlow\r\nGit Flow 不是内置命令，需要单独安装\r\n\r\n**初始化** 每个仓库都必须初始化一次\r\n```bash\r\n# 通常直接回车以完成默认设置\r\ngit flow init\r\n```\r\n\r\n**功能**\r\n```bash\r\n# 开启新的功能\r\ngit flow feature start v1.1.0\r\n\r\n# 推送到远程, 在团队协作中这一步少不了\r\ngit flow feature publish v1.1.0\r\n\r\n# 完成功能, 会将当前分支合并到 develop 然后删除分支，回到 develop\r\ngit flow feature finish v1.1.0\r\n```\r\n\r\n\r\n**打补丁**\r\n\r\nhotfix是针对 `master` 进行打补丁的\r\n```bash\r\n# 开启新的 hotfix\r\ngit flow hotfix start v1.1.0_hotifx\r\n\r\n# 推送到远程\r\ngit flow hotfix publish v1.1.0_hotifx\r\n\r\n# 完成新的hotfix, 将当前分支合并到 master 和 develop，然后删除分支，回到 develop\r\ngit flow hotfix finish v1.1.0_hotifx\r\n```\r\n\r\n**发布**\r\n```bash\r\n# 开启新的 release\r\ngit flow release start v1.1.0\r\n\r\n# 推送到远程\r\ngit flow release publish v1.1.0\r\n\r\n# 完成, 将当前分支合并到 master 和 develop，删除当前分支然后回到 develop\r\ngit flow release finish v1.1.0\r\n```\r\n\r\n#### Git flow schema\r\n\r\n![](media/git-flow.png)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 子模块\r\n具体使用还可以看这里 [git submodule子模块使用教程](https://www.xiejiahe.com/blog/detail/5dbceefc0bb52b1c88c30853)\r\n```bash\r\n# 添加子模块\r\ngit submodule add https://github.com/xjh22222228/git-manual.git\r\n\r\n# 更新，有2种方法\r\n# 一步到位\r\ngit submodule update --remote\r\n# 或者进入到子模块项目再拉取\r\ngit pull\r\n\r\n# 修复子模块分支指向 detached head\r\ngit submodule foreach -q --recursive 'git checkout $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)'\r\n\r\n# 删除子模块 common 为子模块名称，一般删除需要三部\r\ngit submodule deinit <common>\r\n# 清除子模块缓存\r\ngit rm --cached common\r\n# 提交代码并推送\r\ngit commit -am \"Remove a submodule\" && git push\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 帮助\r\n```bash\r\n# 详细打印所有git命令\r\ngit help\r\n\r\n# 打印所有git命令, 此命令不会有详细信息，更清晰一些\r\ngit help -a\r\n\r\n# 列出所有可配置的变量\r\ngit help -c\r\n```\r\n\r\n\r\n\r\n## 清空commit历史\r\n假设当前分支是 `develop`\r\n```bash\r\n# 1、新建一个新分支\r\ngit checkout --orphan new_branch\r\n# 2、暂存所有文件并提交\r\ngit add -A && git commit -m \"First commit\"\r\n# 3、删除本地 develop 分支\r\ngit branch -D develop\r\n# 4、再将 new_branch 分支重命名为 develop\r\ngit branch -m develop\r\n# 5、强制将 develop 分支推送到远程\r\ngit push -f origin develop\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 其他\r\n```bash\r\n# 查看git版本\r\ngit --version\r\n\r\n# 查看远程仓库地址\r\ngit remote -v\r\n\r\n# 记住提交账号密码\r\ngit config --global credential.helper store\r\n\r\n# 清除git已保存的用户名和密码\r\n# windows\r\ngit credential-manager uninstall\r\n# mac linux\r\ngit config --global credential.helper \"\"\r\n# 或者\r\ngit config --global --unset credential.helper\r\n\r\n# 清除本地git缓存\r\ngit rm -r --cached .\r\n```\r\n",
      "data": {
        "title": "Git: 常用命令参考手册",
        "date": "2020-05-14 16:44:10",
        "tags": [
          "Git"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/git-base.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "git-base-CL"
    },
    {
      "content": "> MongoDB的`aggretation pipeline`(聚合管道)查询：把查询分为多个 `stage`(阶段)，每个阶段的输入只依赖于上个阶段的输出。接下来记录一些基本的管道操作符用法。\r\n\r\n### 导入样例数据\r\n```json\r\nperson.json:\r\n{\"_id\":{\"$oid\":\"5ebfef770855d7b7e372f0f4\"},\"name\":\"Tom\",\"age\":25,\"gender\":1,\"hobbies\":[\"basketball\",\"run\",\"swim\",\"eat\"]}\r\n{\"_id\":{\"$oid\":\"5ebfefb10855d7b7e372f10d\"},\"name\":\"Jay\",\"age\":20,\"gender\":1,\"hobbies\":[\"football\",\"swim\",\"sing\"]}\r\n{\"_id\":{\"$oid\":\"5ebfeffa0855d7b7e372f11a\"},\"name\":\"Hellen\",\"age\":15,\"gender\":0,\"hobbies\":[\"yoga\",\"ride\",\"sing\"]}\r\n{\"_id\":{\"$oid\":\"5ebff02b0855d7b7e372f120\"},\"name\":\"Jack\",\"age\":20,\"gender\":1,\"hobbies\":[\"eat\",\"basketball\",\"sing\"]}\r\n{\"_id\":{\"$oid\":\"5ebff0620855d7b7e372f12d\"},\"name\":\"Lucy\",\"age\":17,\"gender\":0,\"hobbies\":[\"sing\",\"ride\",\"program\"]}\r\n\r\nsales.json:\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e1\"},\"item\":\"abc\",\"price\":{\"$numberDecimal\":\"10\"},\"quantity\":2,\"date\":{\"$date\":\"2014-03-01T08:00:00Z\"}}\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e2\"},\"item\":\"jkl\",\"price\":{\"$numberDecimal\":\"20\"},\"quantity\":1,\"date\":{\"$date\":\"2014-03-01T09:00:00Z\"}}\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e3\"},\"item\":\"xyz\",\"price\":{\"$numberDecimal\":\"5\"},\"quantity\":10,\"date\":{\"$date\":\"2014-03-15T09:00:00Z\"}}\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e4\"},\"item\":\"xyz\",\"price\":{\"$numberDecimal\":\"5\"},\"quantity\":20,\"date\":{\"$date\":\"2014-04-04T11:21:39.736Z\"}}\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e5\"},\"item\":\"abc\",\"price\":{\"$numberDecimal\":\"10\"},\"quantity\":10,\"date\":{\"$date\":\"2014-04-04T21:23:13.331Z\"}}\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e6\"},\"item\":\"def\",\"price\":{\"$numberDecimal\":\"7.5\"},\"quantity\":5,\"date\":{\"$date\":\"2015-06-04T05:08:13Z\"}}\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e7\"},\"item\":\"def\",\"price\":{\"$numberDecimal\":\"7.5\"},\"quantity\":10,\"date\":{\"$date\":\"2015-09-10T08:43:00Z\"}}\r\n{\"_id\":{\"$oid\":\"5ec0b2274bac27ea3ba384e8\"},\"item\":\"abc\",\"price\":{\"$numberDecimal\":\"10\"},\"quantity\":5,\"date\":{\"$date\":\"2016-02-06T20:20:13Z\"}}\r\n```\r\n\r\n### $match(筛选)\r\n> 在person中查询age大于等于20,name为Tom或者Jay的记录\r\n```shell\r\ndb.person.aggregate([\r\n    {\r\n        $match: {\r\n            name: {\r\n                $in: [ \"Tom\", \"Jay\" ]\r\n            },\r\n            age: {\r\n                $gte: 20\r\n            }\r\n        }\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : ObjectId(\"5ebfef770855d7b7e372f0f4\"),\r\n        \"name\" : \"Tom\",\r\n        \"age\" : 25,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : [\r\n                \"basketball\",\r\n                \"run\",\r\n                \"swim\",\r\n                \"eat\"\r\n        ]\r\n},\r\n{\r\n        \"_id\" : ObjectId(\"5ebfefb10855d7b7e372f10d\"),\r\n        \"name\" : \"Jay\",\r\n        \"age\" : 20,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : [\r\n                \"football\",\r\n                \"swim\",\r\n                \"sing\"\r\n        ]\r\n}\r\n```\r\n---\r\n### $project(投影)\r\n> 对name为Lucy的person文档进行重新组合\r\n```shell\r\ndb.person.aggregate([\r\n    {\r\n        $match: {\r\n            name: 'Lucy'\r\n        }\r\n    },\r\n    {\r\n        $project: {\r\n            _id: 0,\r\n            name: 1,\r\n            age: 1,\r\n            newArray: [ \"$name\", \"$age\" ],\r\n            nameFirstWord: {\r\n                $substr: [ \"$name\", 0, 1 ]\r\n            },\r\n            ageAddOne: {\r\n                $add: [\"$age\", 1]\r\n            },\r\n            renameHobbies_interest: \"$hobbies\",\r\n            subDocument_nameInfo: {\r\n                name: \"$name\"\r\n            }\r\n        }\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"name\" : \"Lucy\",\r\n        \"age\" : 17,\r\n        \"newArray\" : [\r\n                \"Lucy\",\r\n                17\r\n        ],\r\n        \"nameFirstWord\" : \"L\",\r\n        \"ageAddOne\" : 18,\r\n        \"renameHobbies_interest\" : [\r\n                \"sing\",\r\n                \"ride\",\r\n                \"program\"\r\n        ],\r\n        \"subDocument_nameInfo\" : {\r\n                \"name\" : \"Lucy\"\r\n        }\r\n}\r\n```\r\n---\r\n### $limit(文档数量限制)\r\n> 取出两个person数据\r\n```shell\r\ndb.person.aggregate([\r\n    {\r\n        $limit: 2\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : ObjectId(\"5ebfef770855d7b7e372f0f4\"),\r\n        \"name\" : \"Tom\",\r\n        \"age\" : 25,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : [\r\n                \"basketball\",\r\n                \"run\",\r\n                \"swim\",\r\n                \"eat\"\r\n        ]\r\n},\r\n{\r\n        \"_id\" : ObjectId(\"5ebfefb10855d7b7e372f10d\"),\r\n        \"name\" : \"Jay\",\r\n        \"age\" : 20,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : [\r\n                \"football\",\r\n                \"swim\",\r\n                \"sing\"\r\n        ]\r\n}\r\n```\r\n---\r\n### $skip(跳过管道文档)\r\n> 从第4个开始取出person数据\r\n```shell\r\ndb.person.aggregate([\r\n    {\r\n        $skip: 3\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : ObjectId(\"5ebff02b0855d7b7e372f120\"),\r\n        \"name\" : \"Jack\",\r\n        \"age\" : 20,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : [\r\n                \"eat\",\r\n                \"basketball\",\r\n                \"sing\"\r\n        ]\r\n},\r\n{\r\n        \"_id\" : ObjectId(\"5ebff0620855d7b7e372f12d\"),\r\n        \"name\" : \"Lucy\",\r\n        \"age\" : 17,\r\n        \"gender\" : 0,\r\n        \"hobbies\" : [\r\n                \"sing\",\r\n                \"ride\",\r\n                \"program\"\r\n        ]\r\n}\r\n```\r\n---\r\n### $sort(排序)\r\n> 分页取出person数据：按age降序，第2页，每页2个\r\n```shell\r\ndb.person.aggregate([\r\n    {\r\n        $sort: {\r\n            age: -1\r\n        }\r\n    },\r\n    {\r\n        $skip: 2\r\n    },\r\n    {\r\n        $limit: 2\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : ObjectId(\"5ebff02b0855d7b7e372f120\"),\r\n        \"name\" : \"Jack\",\r\n        \"age\" : 20,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : [\r\n                \"eat\",\r\n                \"basketball\",\r\n                \"sing\"\r\n        ]\r\n},\r\n{\r\n        \"_id\" : ObjectId(\"5ebff0620855d7b7e372f12d\"),\r\n        \"name\" : \"Lucy\",\r\n        \"age\" : 17,\r\n        \"gender\" : 0,\r\n        \"hobbies\" : [\r\n                \"sing\",\r\n                \"ride\",\r\n                \"program\"\r\n        ]\r\n}\r\n```\r\n---\r\n### $unwind(展开数组)\r\n> 对person中name为Jay的数据的hobbies进行展开\r\n```shell\r\ndb.person.aggregate([\r\n    {\r\n        $match: {\r\n            name: \"Jay\"\r\n        }\r\n    },\r\n    {\r\n        $unwind: \"$hobbies\"\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : ObjectId(\"5ebfefb10855d7b7e372f10d\"),\r\n        \"name\" : \"Jay\",\r\n        \"age\" : 20,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : \"football\"\r\n},\r\n{\r\n        \"_id\" : ObjectId(\"5ebfefb10855d7b7e372f10d\"),\r\n        \"name\" : \"Jay\",\r\n        \"age\" : 20,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : \"swim\"\r\n},\r\n{\r\n        \"_id\" : ObjectId(\"5ebfefb10855d7b7e372f10d\"),\r\n        \"name\" : \"Jay\",\r\n        \"age\" : 20,\r\n        \"gender\" : 1,\r\n        \"hobbies\" : \"sing\"\r\n}\r\n```\r\n---\r\n### $group(分组)\r\n> 对sales进行统计分析\r\n\r\n - 计算总的销售额\r\n```shell\r\ndb.sales.aggregate([\r\n    {\r\n        $group: {\r\n            _id: null,\r\n            totalSaleAmount: {\r\n                $sum: {\r\n                    $multiply: [ \"$price\", \"$quantity\" ]\r\n                }\r\n            }\r\n        }\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{ \"_id\" : null, \"totalSaleAmount\" : NumberDecimal(\"452.5\") }\r\n```\r\n- 根据item进行分组，统计每组的总的销售额，降序展示销售额大于100的数据\r\n```shell\r\ndb.sales.aggregate([\r\n    {\r\n        $group: {\r\n            _id: \"$item\",\r\n            saleAmount: {\r\n                $sum: {\r\n                    $multiply: [ \"$price\", \"$quantity\" ]\r\n                }\r\n            }\r\n        }\r\n    },\r\n    {\r\n        $match: {\r\n            saleAmount: {\r\n                $gt: 100\r\n            }\r\n        }\r\n    },\r\n    {\r\n        $sort: {\r\n            saleAmount: -1\r\n        }\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : \"abc\",\r\n        \"saleAmount\" : NumberDecimal(\"170\")\r\n},\r\n{\r\n        \"_id\" : \"xyz\",\r\n        \"saleAmount\" : NumberDecimal(\"150\")\r\n},\r\n{\r\n        \"_id\" : \"def\",\r\n        \"saleAmount\" : NumberDecimal(\"112.5\")\r\n}\r\n```\r\n- 2015-01-01以后，根据日期（YYYY-MM-dd）分组，计算出每个分组的销售总额，平均销售数，文档条数。按销售总额升序输出\r\n```shell\r\ndb.sales.aggregate([\r\n    {\r\n        $match: {\r\n            date: {\r\n                $gt: new ISODate(\"2015-01-01\")\r\n            }\r\n        }\r\n    },\r\n    {\r\n        $group: {\r\n            _id: {\r\n                $dateToString: {\r\n                    format: \"%Y-%m-%d\",\r\n                    date: \"$date\"\r\n                }\r\n            },\r\n            totalSaleAmount: {\r\n                $sum: {\r\n                    $multiply: [ \"$price\", \"$quantity\" ]\r\n                }\r\n            },\r\n            averageQuantity: {\r\n                $avg: \"$quantity\"\r\n            },\r\n            count: {\r\n                $sum: 1\r\n            }\r\n        }\r\n    },\r\n    {\r\n        $sort: {\r\n            totalSaleAmount: 1\r\n        }\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : \"2015-06-04\",\r\n        \"totalSaleAmount\" : NumberDecimal(\"37.5\"),\r\n        \"averageQuantity\" : 5,\r\n        \"count\" : 1\r\n},\r\n{\r\n        \"_id\" : \"2016-02-06\",\r\n        \"totalSaleAmount\" : NumberDecimal(\"50\"),\r\n        \"averageQuantity\" : 5,\r\n        \"count\" : 1\r\n},\r\n{\r\n        \"_id\" : \"2015-09-10\",\r\n        \"totalSaleAmount\" : NumberDecimal(\"75.0\"),\r\n        \"averageQuantity\" : 10,\r\n        \"count\" : 1\r\n}\r\n```\r\n- 按日期（YYYY）分组，统计每年一共的item类型（包含不去重和去重的结果）\r\n```shell\r\ndb.sales.aggregate([\r\n    {\r\n        $group: {\r\n            _id: {\r\n                $dateToString: {\r\n                    format: \"%Y\",\r\n                    date: \"$date\"\r\n                }\r\n            },\r\n            hasDupItems: {\r\n                $push: \"$item\"\r\n            },\r\n            uniqueItems: {\r\n                $addToSet: \"$item\"\r\n            }\r\n        }\r\n    }\r\n])\r\n```\r\n结果：\r\n```json\r\n{\r\n        \"_id\" : \"2016\",\r\n        \"hasDupItems\" : [\r\n                \"abc\"\r\n        ],\r\n        \"uniqueItems\" : [\r\n                \"abc\"\r\n        ]\r\n},\r\n{\r\n        \"_id\" : \"2014\",\r\n        \"hasDupItems\" : [\r\n                \"abc\",\r\n                \"jkl\",\r\n                \"xyz\",\r\n                \"xyz\",\r\n                \"abc\"\r\n        ],\r\n        \"uniqueItems\" : [\r\n                \"abc\",\r\n                \"jkl\",\r\n                \"xyz\"\r\n        ]\r\n},\r\n{\r\n        \"_id\" : \"2015\",\r\n        \"hasDupItems\" : [\r\n                \"def\",\r\n                \"def\"\r\n        ],\r\n        \"uniqueItems\" : [\r\n                \"def\"\r\n        ]\r\n}\r\n```\r\n*OVER~*\r\n\r\n参考文档：\r\n    [MongoDB 聚合管道（Aggregation Pipeline）](https://blog.51cto.com/shanyou/1345924)\r\n    [Official documents](https://docs.mongodb.com/manual/core/aggregation-pipeline/)\r\n\r\n",
      "data": {
        "title": "MongoDB: Aggregation 简单使用",
        "date": "2020-05-13 18:09:17",
        "tags": [
          "MongoDB"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/mongodb-aggregation.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mongodb-aggregation"
    },
    {
      "content": "```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"app\">\r\n        <p>message: {{ message }}</p>\r\n        <p>reversedMessageComputed: {{ reversedMessageComputed }}</p>\r\n        <p>reversedMessageMethod: {{ reversedMessageMethod() }}</p>\r\n        <p>reversedMessageWatch: {{ reversedMessageWatch }}</p>\r\n        <input v-model=\"message\" />\r\n        <br />\r\n        <template v-if=\"message === 'username'\">\r\n            <label>Username</label>\r\n            <input placeholder=\"Enter your username\" key=\"username-input\">\r\n        </template>\r\n        <template v-else>\r\n            <label>Email</label>\r\n            <input placeholder=\"Enter your email address\" key=\"email-input\">\r\n        </template>\r\n\r\n        <ul>\r\n            <li v-for=\"(value, index) in persons\">\r\n                {{ index }}: {{ value }}\r\n            </li>\r\n        </ul>\r\n\r\n        <ul>\r\n            <li v-for=\"value of persons\">\r\n                {{ value }}\r\n            </li>\r\n        </ul>\r\n\r\n        <ul>\r\n            <li v-for=\"(value, name, index) of personMars\">\r\n                {{ index }}. {{ name }}: {{ value }}\r\n            </li>\r\n        </ul>\r\n\r\n        <button @click=\"clickBtn({message: 'message', event: $event})\">{{ message }}</button>\r\n\r\n        <form @submit.prevent=\"onSubmit\">\r\n            <button>submit</button>\r\n        </form>\r\n\r\n        <span style=\"background-color: red\" @click=\"clickSpanOne\">\r\n            span1\r\n            <span style=\"background-color: black\" @click.stop=\"clickSpanTwo\">span2</span>\r\n        </span>\r\n        <br />\r\n        <input @keyup.enter=\"clickEnter\" />\r\n        <br />\r\n        <div :style=\"{ fontSize: postFontSize + 'em' }\">\r\n            <blog v-for=\"post of posts\" :key=\"post.id\" :post=\"post\" @enlarge-text=\"enlargeText\" />\r\n        </div>\r\n        <br />\r\n        <input v-model=\"searchText\" />\r\n        <br />\r\n        <input :value=\"searchTextSelf\" @input=\"searchTextSelf=$event.target.value\" />\r\n        <br />\r\n        <custom-input :value=\"searchTextCustom\" @input=\"searchTextCustom=$event\"></custom-input>\r\n        <custom-input v-model=\"searchTextCustom\"></custom-input>\r\n        <br />\r\n        <component :is=\"myComponent\"></component>\r\n        <my-component></my-component>\r\n        <my-props-component\r\n            test-str=\"this is testStr\"\r\n            :test-arr=\"[1, 2]\"\r\n            test-arr-str=\"[1, 2]\"\r\n        >\r\n        </my-props-component>\r\n        1\r\n    </div>\r\n</body>\r\n<script>\r\n    Vue.component('blog', {\r\n        data: function () {\r\n            return {\r\n                changedPost: this.post\r\n            }\r\n        },\r\n        props: {\r\n            post: Object\r\n        },\r\n        methods: {\r\n            changePost() {\r\n                this.changedPost = {\r\n                    title: 'changed title',\r\n                    content: 'changed content'\r\n                }\r\n            }\r\n        },\r\n        template: `\r\n            <div>\r\n                <div>{{ changedPost.title }}</div>\r\n                <div>{{ changedPost.content }}</div>\r\n                <button v-on:click=\"$emit('enlarge-text', 1, 'test')\">\r\n                    Enlarge text\r\n                </button>\r\n                <button v-on:click=\"changePost\">\r\n                    changePost\r\n                </button>\r\n                <br />\r\n                -----------------------------\r\n            </div>\r\n        `\r\n    })\r\n\r\n    Vue.component('custom-input', {\r\n        data: function () {\r\n            return {\r\n            }\r\n        },\r\n        props: [\r\n            'value'\r\n        ],\r\n        template: `\r\n            <div>\r\n                <input\r\n                    v-bind:value=\"value\"\r\n                    v-on:input=\"$emit('input', $event.target.value)\"\r\n                />\r\n            </div>\r\n        `\r\n    })\r\n\r\n    let MyComponent = {\r\n        data () {\r\n            return {\r\n            }\r\n        },\r\n        props: [\r\n        ],\r\n        template: `\r\n            <div>my test component</div>\r\n        `\r\n    }\r\n    \r\n    let MyPropsComponent = {\r\n        data () {\r\n            return {\r\n            }\r\n        },\r\n        props: {\r\n            testStr: String,\r\n            testArr: Array,\r\n            testArrStr: String\r\n        },\r\n        template: `\r\n            <div>\r\n                <div>testStr: {{ testStr }}</div>\r\n                <div>testArr: {{ testArr[0] }}</div>\r\n                <div>testArrStr: {{ typeof testArrStr }}</div>\r\n            </div>\r\n        `\r\n    }\r\n\r\n    \r\n    const app = new Vue({\r\n        el: '#app',\r\n        components: {\r\n            MyComponent,\r\n            MyPropsComponent\r\n        },\r\n        data: {\r\n            message: 'Hello Vue!',\r\n            reversedMessageWatch: '',\r\n            loginType: 'username',\r\n            persons: [\r\n                'mars',\r\n                'leo',\r\n                'dale'\r\n            ],\r\n            personMars: {\r\n                name: 'mars',\r\n                age: 24,\r\n                country: 'china'\r\n            },\r\n            posts: [\r\n                { id: 1, title: 'Vue 组件', content: '这是一个内容' },\r\n                { id: 2, title: 'Vue 组件', content: '这是一个内容' }\r\n            ],\r\n            postFontSize: 1,\r\n            searchText: 'hello mars',\r\n            searchTextSelf: 'hello mars',\r\n            searchTextCustom: 'hello mars',\r\n            myComponent: 'my-component'\r\n        },\r\n        computed: {\r\n            reversedMessageComputed() {\r\n                return this.message.split('').reverse().join('')\r\n            }\r\n        },\r\n        methods: {\r\n            reversedMessageMethod() {\r\n                return this.message.split('').reverse().join('')\r\n            },\r\n            clickBtn({ message, event }) {\r\n                console.log({ message, event })\r\n            },\r\n            onSubmit() {\r\n                console.log('Submit')\r\n            },\r\n            clickSpanOne() {\r\n                console.log('clickSpanOne')\r\n            },\r\n            clickSpanTwo() {\r\n                console.log('clickSpanTwo')\r\n            },\r\n            clickEnter() {\r\n                console.log('click enter')\r\n            },\r\n            enlargeText(enlargeAmount, test) {\r\n                console.log(test)\r\n                this.postFontSize += enlargeAmount\r\n            }\r\n        },\r\n        watch: {\r\n            message() {\r\n                this.reversedMessageWatch = this.message.split('').reverse().join('')\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n</html>\r\n```",
      "data": {
        "title": "Vue: demo",
        "date": "2020-05-06 19:51:54",
        "tags": [
          "Vue"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/vue-demo.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vue-demo"
    },
    {
      "content": "> 众所周知，JS中处处存在的异步操作，各种各样的 `callBack`。这使我们不论书写还是阅读代码都产生了种种的不变。为了避免过多的、依赖的异步操作造成回调地狱，`Promise` 使得我们可以链式的书写嵌套回调，`async/await` 语法糖更是可以让我们以同步的方式书写相互依赖的异步操作。又可以优雅的🐱写bug了呢！！~接下来以文件的读取这个异步操作为例，分别记录：\r\n---\r\n### **回调函数**\r\n上code:\r\n```js\r\nconst fs = require('fs')\r\nfs.readFile('./file1.txt', (error, data) => {\r\n    if (error) console.log('oh no', error)\r\n    else {\r\n        console.log(data.toString())\r\n        fs.readFile('./file2.txt', (error, data) => {\r\n            if (error) console.log('oh no', error)\r\n            else {\r\n                console.log(data.toString())\r\n            }\r\n        })\r\n    }\r\n})\r\n```\r\noutput:\r\n```shell\r\nE:\\ES6  (es6@1.0.0)\r\nλ node promise.js\r\nthis is file one\r\nthis is file two\r\n```\r\n假如文件的读取相互依赖，又由于文件的读取属于异步操作只能靠回调函数进行文件读取后的操作，这种情况下，就会形成回调地狱🕳👻`callback hell`!!!。这种代码将会变得越来越*胖*，显然让人看起来很不舒服。\r\n\r\n### **Promise**\r\n`Promise` 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。\r\n-  基本语法\r\n```js\r\nconst promise = new Promise(function(resolve, reject) {\r\n    // ... some async operations\r\n\r\n    if (/* 异步操作成功 */) {\r\n        resolve(value)\r\n    } else {\r\n        reject(error)\r\n    }\r\n})\r\n```\r\n`Promise` 可以使得我们摆脱无尽的回调，可以采用链式编程。接下来使用 `Promise` 解决文件的读取相互依赖问题。\r\n```js\r\nconst fs = require('fs')\r\nfunction readFilePromise (path) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.readFile(path, (error, data) => {\r\n            if (error) reject(error)\r\n            else resolve(data)\r\n        })\r\n    })\r\n}\r\n\r\nreadFilePromise('./file1.txt')\r\n    .then((data) => {\r\n        console.log(data.toString())\r\n        return readFilePromise('./file2.txt')\r\n    })\r\n    .then((data) => {\r\n        console.log(data.toString())\r\n    })\r\n    .catch((error) => console.log('oh no', error))\r\n```\r\noutput:\r\n```shell\r\nE:\\ES6  (es6@1.0.0)\r\nλ node promise.js\r\nthis is file one\r\nthis is file two\r\n```\r\n从code中可以看出，如果想使用 `Promise` ，首先需要将文件读取的异步操作封装成一个 `Promise` 对象，然后，异步操作完成调用 `resolve` 函数，最后使用 `.then` 接收异步执行结果。但是，如果每次都需要手动将异步操作封装成 `Promise` 也太~~扯蛋~~麻烦了吧~好在 `Node` 中提供了 `promisify` 这个库。\r\n```js\r\nconst fs = require('fs')\r\nconst promisify = require('util').promisify\r\nconst promisifyReadFile = promisify(fs.readFile)\r\n\r\npromisifyReadFile('./file1.txt')\r\n    .then((data) => {\r\n        console.log(data.toString())\r\n        return promisifyReadFile('./file2.txt')\r\n    })\r\n    .then((data) => {\r\n        console.log(data.toString())\r\n    })\r\n    .catch((error) => console.log('oh no', error))\r\n```\r\n偷懒是程序员的美德嘛。但是其实，`Promise` 只是一个容器，一个外壳。这样好像还不是很完美！\r\n\r\n### **async/await**\r\n其实，`async` 和 `await` 是 [Generator](https://es6.ruanyifeng.com/#docs/generator)的语法糖，他们是建立在 `Promise` 机制上的。从字面上就可以大致理解他们的作用。接下来，基于手动封装的 `readFilePromise` 实现优雅书写代码：\r\n```js\r\nasync function readFileAsync() {\r\n    try {\r\n        let data1 = await readFilePromise('./file1.txt')\r\n        let data2 = await readFilePromise('./file2.txt')\r\n        console.log(data1.toString())\r\n        console.log(data2.toString())\r\n    } catch (error) {\r\n        console.log('oh no', error)\r\n    }\r\n}\r\n\r\nreadFileAsync()\r\n```\r\noutput:\r\n```shell\r\nE:\\ES6  (es6@1.0.0)\r\nλ node promise.js\r\nthis is file one\r\nthis is file two\r\n```\r\n上面的code的逻辑是建立在*假设文件的读写存在相互的依赖关系*，即文件 `file1.txt` 和文件 `file2.txt `的读取需要串行的同步执行，假如说文件的读取没有相互的依赖关系，则可以这样实现并行处理：\r\n```js\r\nasync function readFileAsync() {\r\n    try {\r\n        let [data1, data2] = await Promise.all([\r\n            readFilePromise('./file1.txt'),\r\n            readFilePromise('./file2.txt')\r\n        ])\r\n        console.log(data1.toString())\r\n        console.log(data2.toString())\r\n    } catch (error) {\r\n        console.log('oh no', error)\r\n    }\r\n}\r\n\r\nreadFileAsync()\r\n```\r\n\r\n\r\n---\r\n最后，别以为你逃离了`callBack hell`，你还有可能陷入`async/await hell`!!! 也许这篇文章可以帮助你 ---> [✨](https://www.freecodecamp.org/news/avoiding-the-async-await-hell-c77a0fb71c4c/)\r\nOVER!🤐",
      "data": {
        "title": "ES6：异步编程解决方案",
        "date": "2020-05-04 14:50:54",
        "tags": [
          "ES6"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/promises-methods.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "asyncProgrammingSolution"
    },
    {
      "content": "索引可以提升文档的查询速度，首先模拟不建立索引和建立索引之后的查询速度对比。\r\n- 首先插入测试数据\r\n```js\r\ntest.js:\r\nfor(let i = 0; i < 100000; i++) {\r\n\tdb.person.insert({ name: 'test'+i ,age: NumberInt(i) })\r\n}\r\n```\r\n```shell\r\nmongo test test.js\r\n```\r\n- 未建立索引，执行查询语句\r\n```js\r\n> db.person.find({name: \"test30000\"}).explain(\"executionStats\")\r\n\r\n        \"executionStats\" : {\r\n                \"executionSuccess\" : true,\r\n                \"nReturned\" : 1,\r\n                \"executionTimeMillis\" : 45,\r\n                \"totalKeysExamined\" : 0,\r\n                \"totalDocsExamined\" : 100000,\r\n                \"executionStages\" : {\r\n                        \"stage\" : \"COLLSCAN\",\r\n                        \"filter\" : {\r\n                                \"name\" : {\r\n                                        \"$eq\" : \"test30000\"\r\n                                }\r\n                        },\r\n                        \"nReturned\" : 1,\r\n                        \"executionTimeMillisEstimate\" : 42,\r\n                        \"works\" : 100002,\r\n                        \"advanced\" : 1,\r\n                        \"needTime\" : 100000,\r\n                        \"needYield\" : 0,\r\n                        \"saveState\" : 781,\r\n                        \"restoreState\" : 781,\r\n                        \"isEOF\" : 1,\r\n                        \"invalidates\" : 0,\r\n                        \"direction\" : \"forward\",\r\n                        \"docsExamined\" : 100000\r\n                }\r\n        }\r\n}\r\n```\r\n> 可以看到，未建立索引执行查询条件未`name`的查询时候，执行时间为`\"executionTimeMillis\" : 45`, 扫描方式为`\"stage\" : \"COLLSCAN\"`，即全表扫描\r\n- 建立索引，然后执行查询\r\n```js\r\n> db.person.createIndex( { name: 1 } )\r\n\r\n        \"createdCollectionAutomatically\" : false,\r\n        \"numIndexesBefore\" : 1,\r\n        \"numIndexesAfter\" : 2,\r\n        \"ok\" : 1\r\n}\r\n```\r\n```js\r\n>  db.person.find({name: \"test30000\"}).explain(\"executionStats\")\r\n\r\n        \"executionStats\" : {\r\n                \"executionSuccess\" : true,\r\n                \"nReturned\" : 1,\r\n                \"executionTimeMillis\" : 18,\r\n                \"totalKeysExamined\" : 1,\r\n                \"totalDocsExamined\" : 1,\r\n                \"executionStages\" : {\r\n                        \"stage\" : \"FETCH\",\r\n                        \"nReturned\" : 1,\r\n                        \"executionTimeMillisEstimate\" : 0,\r\n                        \"works\" : 2,\r\n                        \"advanced\" : 1,\r\n                        \"needTime\" : 0,\r\n                        \"needYield\" : 0,\r\n                        \"saveState\" : 0,\r\n                        \"restoreState\" : 0,\r\n                        \"isEOF\" : 1,\r\n                        \"invalidates\" : 0,\r\n                        \"docsExamined\" : 1,\r\n                        \"alreadyHasObj\" : 0,\r\n                        \"inputStage\" : {\r\n                                \"stage\" : \"IXSCAN\",\r\n                                \"nReturned\" : 1,\r\n                                \"executionTimeMillisEstimate\" : 0,\r\n                                \"works\" : 2,\r\n                                \"advanced\" : 1,\r\n                                \"needTime\" : 0,\r\n                                \"needYield\" : 0,\r\n                                \"saveState\" : 0,\r\n                                \"restoreState\" : 0,\r\n                                \"isEOF\" : 1,\r\n                                \"invalidates\" : 0,\r\n                                \"keyPattern\" : {\r\n                                        \"name\" : 1\r\n                                },\r\n                                \"indexName\" : \"name_1\",\r\n                                \"isMultiKey\" : false,\r\n                                \"multiKeyPaths\" : {\r\n                                        \"name\" : [ ]\r\n                                },\r\n                                \"isUnique\" : false,\r\n                                \"isSparse\" : false,\r\n                                \"isPartial\" : false,\r\n                                \"indexVersion\" : 2,\r\n                                \"direction\" : \"forward\",\r\n                                \"indexBounds\" : {\r\n                                        \"name\" : [\r\n                                                \"[\\\"test30000\\\", \\\"test30000\\\"]\"\r\n                                        ]\r\n                                },\r\n                                \"keysExamined\" : 1,\r\n                                \"seeks\" : 1,\r\n                                \"dupsTested\" : 0,\r\n                                \"dupsDropped\" : 0,\r\n                                \"seenInvalidated\" : 0\r\n                        }\r\n                }\r\n        }\r\n}\r\n```\r\n> 建立索引后，执行时间为`\"executionTimeMillis\" : 18`, 扫描方式为`IXSCAN`，即从索引中查找。\r\n\r\n通过对比可以看出，建立索引可以提升查询的速度。接下来记录为何索引可以提升文档查询的速度。\r\n--- \r\n### 索引的原理\r\n当执行插入语句的时候，每个文档经过数据库的存储引擎持久化后，会有一个位置信息，通过这个位置信息，就能从存储引擎里读出该文档。下表大致描述：\r\n| 位置 | 文档 |\r\n| ----------------------------- |  ----------------------------- |\r\n| pos0 | {\"name\" : \"leo\", \"score\" : 38} |  \r\n| pos1 | {\"name\" : \"yanina\", \"score\" : 24} |  \r\n| pos2 | {\"name\" : \"mars\", \"score\" : 23} |  \r\n| pos3 | {\"name\" : \"dale\", \"score\" : 22} |  \r\n| pos4 | {\"name\" : \"baby\", \"score\" : 2} |  \r\n...\r\n此时如果要执行查询语句`db.person.find({score: 23})`，则需要全盘扫描`person` 集合，当满足条件`score: 23`时，得到文档的位置信息`pos2`，进而取出相关文档\r\n当给字段`score`添加索引后（`db.person.createIndex( { score: 1 } )`），MongoDB会额外存储一份按`score`字段升序排序的索引数据，索引结构类似如下:\r\n| age | 位置 |\r\n| ----------------------------- |  ----------------------------- |\r\n| 2 | pos4 |  \r\n| 22 | pos3 |  \r\n| 23 | pos2 |  \r\n| 24 | pos1 |  \r\n| 38 | pos0 |  \r\n...\r\n简单的说，索引就是将文档按照某个（或某些）字段顺序组织起来，以便能根据该字段高效的查询。此时执行查询语句`db.person.find({score: 23})`，只会扫描部分文档，得到位置信息则可取出文档。\r\n或者来张图片更加易懂？\r\n![](http://404j.fun/post-images/1588065623029.svg)\r\n\r\n---\r\n参考文档：\r\n[MongoDB索引原理](https://mongoing.com/archives/2797)",
      "data": {
        "title": " MongoDB: 索引",
        "date": "2020-04-28 15:38:24",
        "tags": [
          "MongoDB"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/mongo_index.svg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mongodb-suo-yin"
    },
    {
      "content": "#### 安装\r\n一般在安装`Node`之后，NPM作为`Node`的默认包管理器，已经被安装好了。可以执行 `npm -v`查看当前`NPM`版本\r\n```shell\r\nλ npm -v\r\n6.9.0\r\n```\r\n---\r\n#### 使用NPM安装依赖包\r\n以 `express`为例子。执行该命令的时候，首先会在当前目录检查是否有`node_modules`该文件夹，没有则创建。然后在`node_modules`目录下创建`express`目录。在代码中直接`require('express')`即可引用该包。\r\n\r\n`Node`中，使用`require`可以引用🔽\r\n1. 核心模块即`Node`内置的模块如fs, `require('fs')`；\r\n2. 文件模块即dev自己开发的模块，`require('../hello.js')`；\r\n3. 第三方模块，如`express`, `require('express')`, `Node`会首先查询当前文件目录下的`node_modules`目录，所以npm进行包管理和`Node`模块引用是相辅相成的。\r\n```shell\r\nλ npm install express\r\n...\r\n+ express@4.17.1\r\nadded 50 packages from 37 contributors and audited 126 packages in 6.899s\r\nfound 0 vulnerabilities\r\n```\r\n---\r\n#### 使用NPM移除依赖包\r\n对上面安装的`express`包进行移除\r\n```shell\r\nλ npm uninstall express\r\n...\r\nremoved 1 package and audited 160 packages in 1.452s\r\nfound 0 vulnerabilities\r\n```\r\n---\r\n#### 发布包\r\n简单记录如何将自己开发的模块发布到`NPM`仓库中并通过`NPM`安装。\r\n1. 创建简单的模块`hello.js`\r\n```js\r\nexports.printHello = function () {\r\n  console.log('hello nodejs')\r\n}\r\n```\r\n2. 执行`npm init `创建包描述文件`package.json`\r\n```shell\r\nλ npm init\r\nThis utility will walk you through creating a package.json file.\r\nIt only covers the most common items, and tries to guess sensible defaults.\r\n\r\nSee `npm help json` for definitive documentation on these fields\r\nand exactly what they do.\r\n\r\nUse `npm install <pkg>` afterwards to install a package and\r\nsave it as a dependency in the package.json file.\r\n\r\nPress ^C at any time to quit.\r\npackage name: (hellonpm) hello_npm_404\r\nversion: (1.0.0)\r\ndescription: A hello npm test\r\nentry point: (hello.js)\r\ntest command:\r\ngit repository:\r\nkeywords:\r\nauthor: 404\r\nlicense: (ISC)\r\nAbout to write to C:\\Users\\mars.shi\\Desktop\\helloNPM\\package.json:\r\n\r\n{\r\n  \"name\": \"hello_npm_404\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"A hello npm test\",\r\n  \"main\": \"hello.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"404\",\r\n  \"license\": \"ISC\"\r\n}\r\n\r\n\r\nIs this OK? (yes) yes\r\n```\r\n3. 注册包仓库账号\r\n```shell\r\nλ npm adduser\r\nUsername: 404j\r\nPassword:\r\nEmail: (this IS public) j1491361626@gmail.com\r\nLogged in as 404j on https://registry.npmjs.org/.\r\n```\r\n> 需要`npm`官网验证邮箱呦\r\n1. 上传包\r\n```shell\r\nλ npm publish\r\n...\r\n+ hello_npm_404@1.0.0\r\n```\r\n#### 安装包\r\n切换至另一个目录，执行\r\n```shell\r\nλ npm install hello_npm_404\r\n...\r\n+ hello_npm_404@1.0.0\r\nadded 1 package from 1 contributor and audited 1 package in 2.674s\r\nfound 0 vulnerabilities\r\n```\r\n这样在这个目录就可以引用自己开发的`NPM`包了\r\n```js\r\nconst hello = require('hello_npm_404')\r\nconsole.log(hello.printHello())\r\n```\r\n",
      "data": {
        "title": "NPM 使用",
        "date": "2020-04-18 17:38:47",
        "tags": [
          "NPM",
          "Node",
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/npm.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "npm-shi-yong"
    },
    {
      "content": "首先，浏览器是多进程工作的，每打开一个 tap 页面，就会新开一个独立的浏览器进程。\r\n### 浏览器有哪些主要的进程\r\n1. Browser进程：浏览器的主进程（负责协调、主控）\r\n2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\r\n3. GPU进程：最多一个，用于3D绘制等\r\n4. 浏览器渲染进程（浏览器内核）：**Renderer进程**，内部是多线程的，负责页面渲染，脚本执行，事件处理等\r\n---\r\n### 关于Renderer进程 💥\r\n1. GUI渲染线程\r\n- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等\r\n- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\r\n2. **JS引擎线程** 💥\r\n- 也称为JS内核，负责处理Javascript脚本程序（例如V8引擎）\r\n- 单线程运行js\r\n- **和GUI渲染线程互斥，不会同时运行，由于Js是可以操作DOM的，如果JS引擎线程和GUI渲染线程同时运行，这样就会产生冲突**\r\n3. 事件触发线程\r\n- 当对应事件触发（不论是WebAPIs完成事件触发，还是页面交互事件触发）时，该线程会将事件对应的回调函数放入**callback queue**（任务队列）中，等待js引擎线程的处理\r\n4. 定时触发线程\r\n- 对应于setTimeout，setInterval API，由该线程来计时，当计时结束，将事件对应的回调函数放入任务队列中\r\n- 当setTimeout的定时的时间小于4ms，一律按4ms来算\r\n5. 异步http请求线程\r\n- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\r\n- 将检测到状态变更时，如果设置有回调函数，异步http请求线程就产生状态变更事件，将这个回调放入任务队列中。再由JavaScript引擎执行\r\n![](http://404j.fun/post-images/1587187987879.jpg)\r\n---\r\n### js如何在浏览器中运行 💥\r\n![](http://404j.fun/post-images/1587187994787.jpg)\r\n1. JS引擎线程提供js的运行环境，此时会形成一个**执行栈（stack）**，当调用一个函数时，就把它推入运行时中的栈中\r\n2. **执行栈**中某一函数调用Web Apis接口（诸如发送 HTTP 请求、监听 DOM 事件、延迟执行 setTimeout 或 setInterval）的时候，需要提供一个回调（callback）函数，则 JS 将其控制权连同一个 callback 委派给 Web API 后移动到该函数中的下一行\r\n3. 此时Web Apis中的 事件触发线程/定时触发线程/异步http请求线程 就会去监听这些callback何时触发，当满足触发条件时，就会将这个callback推入到**callback queue**（任务队列）中\r\n4. **事件循环（Event Loop）** 唯一的工作就是盯着 -- 回调队列上一有待执行（pending）的 callback 函数，就将其推入执行栈中；而这一动作发生的时间点，是 **栈一旦为空的时候**\r\n5. 之后此callback就会被执行\r\n\r\n> 接下来上代码：\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <script>\r\n      console.log(1)\r\n      setTimeout(() => {\r\n          console.log(3)\r\n          setTimeout(() =>{\r\n            console.log(5)\r\n          })\r\n      })\r\n      setTimeout(() => {\r\n          console.log(4)\r\n          setTimeout(() => {\r\n            console.log(6)\r\n          })\r\n      })\r\n      console.log(2)\r\n    </script>\r\n  </head>\r\n  <body>\r\n  </body>\r\n</html>\r\n```\r\n> 如你所愿，Browser 中 Console 的打印结果为：1 2 3 4 5 6\r\n---\r\n### macrotask与microtask \r\n> 先来一段代码：\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <script>\r\n      console.log(1)\r\n      setTimeout(() => {\r\n        console.log(2)\r\n        Promise.resolve().then(() => {\r\n          console.log('promise1')\r\n        }).then(() => {\r\n          console.log('promise2')\r\n        })\r\n      })\r\n      setTimeout(() => {\r\n        console.log(3)\r\n      })\r\n    </script>\r\n  </head>\r\n  <body>\r\n  </body>\r\n</html>\r\n```\r\n按照“队列理论”，结果应该为1 2 3 promise1 promise2。很遗憾输出的是1 2 promise1 promise2 3\r\n理解这个需要知道两个概念：\r\n- macrotask：宏任务，任务队列中没有充钱的用户~。包括：原生Promise\r\n- microtask ：微任务，任务队列中的VIP用户。当主线程执行完毕，如果微任务队列中有微任务，则会先进入执行栈，当微任务队列没有任务时，才会执行宏任务的队列。包括：setTimeout, setInterval, setImmediate, I/O\r\n\r\n",
      "data": {
        "title": "JavaScript in browser",
        "date": "2020-04-10 09:19:07",
        "tags": [
          "Browser",
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/js_in_bowser.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "javaScript-in-browser"
    },
    {
      "content": "*记录下常用或者不常用，会用或者不会用的 Linux 文件操作命令*\r\n---\r\n#### 新建\r\n```shell\r\nmkdir <folderName> # 新建文件夹\r\ntouch <fileName> # 新建文件\r\nln -s <source> <dest> # 创建文件软连接(穿个软连接)\r\n```\r\n---\r\n#### 查看\r\n- 查看目录\r\n```shell\r\nll -h or ls -lh # 显示目录文件详细信息\r\ndu -h <fileName or folderName> # 查看文件或者文件夹的大小\r\npwd # 显示当前路径\r\n```\r\n- 查看文件内容\r\n```shell\r\ncat <fileName> # 查看文件的全部内容\r\nhead -<headLine> <fileName> # 查看文件前几行的内容\r\ntail -n <startToTail> -f <fileName> # 显示文件后几行的内容\r\nmore <fileName> # 显示一屏文件内容。Space --> 下一屏内容; Enter --> 下一行内容; Q --> 退出\r\nless <fileName> # 类似于more，值得研究下\r\n🐖：more和less可以结合管道命令：history | more; ps -ef | more\r\n```\r\n- 查看文件状态\r\n```shell\r\nstat <fileName> # 查看文件详细信息\r\n```\r\n- 查看文件类型\r\n```shell\r\nfile <fileName> # 查看文件类型\r\n```\r\n---\r\n#### 删除\r\n```shell\r\nrm -f -i -r <fileName> # f --> force强制删除; i --> interactive交互式删除; r --> recursive递归删除文件夹\r\n```\r\n---\r\n#### 复制\r\n- 本地复制\r\n```shell\r\ncp -r <source> <dest> # r --> 复制文件夹\r\n```\r\n- 远程复制\r\n```shell\r\nscp -r <localFile> <remoteUserName>@<remoteIp>:<remoteFolder> # 本地复制到远程，r --> 复制文件夹\r\nscp -P <port> -r <remoteUserName>@<remoteIp>:<remoteFolder> <localFile> # 远程复制到本地，r --> 复制文件夹, P --> 指定端口\r\n```\r\n---\r\n#### 移到 or 重命名\r\n```shell\r\nmv <source> <dest> # 移动 or 重命名 文件或文件夹\r\n```\r\n---\r\n#### 归档 or 解压缩\r\n- 压缩\r\n```shell\r\ntar -cvf <dest.tar> <source> # 归档成*.tar包, c --> 建立档案; v --> 显示过程; f --> 使用档案名字，必填且最后一个参数\r\ntar -czvf <dest.tar.gz> <source> # 压缩成*.tar.gz文件, z --> 有gzip属性\r\ntar -cjvf <dest.tar.bz2> <source> # 压缩成*.tar.bz2文件, j --> 有bz2属性\r\nzip <dest.zip> <source> # 压缩成*.zip文件\r\n```\r\n- 解压\r\n```shell\r\ntar -xvf <dest.tar> # 展开*.tar包, x --> 解压\r\ntar -xzvf <dest.tar.gz> # 解压*.tar.gz文件\r\ntar -xjvf <dest.tar.bz2> # 解压*.tar.bz2文件\r\nunzip <dest.zip> # 解压*.zip文件\r\n```\r\n> 🐖：[tar vs zip vs gz](https:#itsfoss.com/tar-vs-zip-vs-gz/)\r\n---\r\n#### 查找\r\n```shell\r\nfind <targetFolders> -name <targetName> -type <b/d/c/p/l/f> # type -->块设备、目录、字符设备、管道、符号链接、普通文件\r\nlocate <targetName>\r\nwhereis <targetName>\r\n```\r\n",
      "data": {
        "title": "Linux 命令之文件操作",
        "date": "2020-04-02 09:03:34",
        "tags": [
          "Linux"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/linux_shell_file.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "linux-command-manage-file"
    },
    {
      "content": "**谨以此篇blog记录server的mongoDB被洗空😖~~~**\r\n\r\n### 1. admin db创建超级管理员用户\r\n- 首先进入MongoDB shell\r\n```shell\r\nmongo\r\n```\r\n- 此时默认进入的test数据库，切换到admin数据库。关于admin数据库在mongoDB中的作用，\r\nstackoverflow上的一位网友讲的挺清楚，在此引用一下：*The main purpose of this admin database is to store system collections and user authentication and authorization data, which includes the administrator and user's usernames, passwords, and roles. Access is limited to only to administrators, who have the ability to create, update, and delete users and assign roles.*\r\n```js\r\nuse admin\r\n```\r\n- 创建Administrator\r\n```js\r\ndb.createUser({\r\n    user: <username>,\r\n    pwd: <password>,\r\n    roles: [{\r\n        role: <role>, db: <targetDB> // role一般指定为\"userAdminAnyDatabase\"\r\n    }]\r\n})  \r\n```\r\n> 以下为mongoDB内置的role\r\n\r\n| 分类                          | role(角色) | 简要说明 |\r\n| ----------------------------- | ---------- | -------- |\r\n| 数据库用户角色(DB User Roles) |    `read` `readWrite`        |  为某个数据库创建一个用户, 分配该数据库的读写权力        |\r\n| 数据库管理员角色(DB Admin Roles) | `dbAdmin` `dbOwner` `userAdmin` | 拥有创建数据库, 和创建用户的权力 |\r\n| 集群管理角色(Culster Administration Roles) | `clusterAdmin` `clusterManager` `clusterMonitor` `hostManager` | 管理员组, 针对整个系统进行管理 |\r\n| 备份还原角色(Backup and Restoration Roles) | `backup` `restore` | 备份数据库, 还原数据库 |\r\n| 所有数据库角色(All-Database Roles) | `readAnyDatabase` `readWriteAnyDatabase` `userAdminAnyDatabase` `dbAdminAnyDatabase` | 拥有对admin操作的权限 |\r\n| Superuser Roles(超级管理员) | `root` `dbOwner` `userAdmin` `userAdminAnyDatabase` | 这几个角色角色提供了任何数据任何用户的任何权限的能力，拥有这个角色的用户可以在任何数据库上定义它们自己的权限 |\r\n\r\n### 2. 重启mongo服务，开启认证\r\n- 停止服务\r\n```shell\r\nservice mongodb stop\r\n```\r\n- 修改配置文件\r\n```shell\r\nwhereis mongodb.conf // 查找配置文件\r\nauth = true // 配置文件mongodb.conf 去掉 auth = true 前面的注释\r\n```\r\n- 重启服务\r\n```shell\r\nservice mongodb start\r\nor\r\nmongod -f mongodb.conf\r\n```\r\n\r\n### 3. 认证方式登录mongo\r\n- 登录\r\n```js\r\nmongo\r\nuse admin\r\ndb.auth(<userName>, <password>)\r\nshow users // 查看用户\r\n```\r\n\r\n### 4. 创建指定db 用户\r\n- 认证登录admin后，切换至指定的db, 以管理员身份创建其他用户\r\n```js\r\nuse <targetDB>\r\ndb.createUser({\r\n    user: <username>,\r\n    pwd: <password>,\r\n    roles: [{\r\n        role: <role>, db: <targetDB> // role一般指定为\"readWrite\"\r\n    }]\r\n})\r\nshow users // 可以通过 _id确定用户所指定的数据库\r\n```\r\n\r\n### 5. 修改用户密码及删除用户\r\n- 首先以管理员身份登录admin，然后进行修改一般用户密码操作\r\n```js\r\nuse <targetDB> // 切换到待修改用户所在的db, 否则 user note found error\r\ndb.changeUserPassword(<userName>, <password>)\r\n```\r\n- 删除一般用户操作\r\n```js\r\nuse <targetDB> // 切换到待删除用户所在的db, 否则 user note found error\r\ndb.dropUser(<userName>)\r\n```",
      "data": {
        "title": "Mongodb 用户管理",
        "date": "2020-03-28 13:14:14",
        "tags": [
          "MongoDB"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/mongodb_logo.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mongo-user-management"
    },
    {
      "content": "**Yanina 👧 is very beautiful, and she is also very slim!**\r\n```js\r\nvar person = {\r\n    firstName: 'Mars',\r\n    lastName: 'Shi',\r\n    fullName: function () {\r\n        console.log(this.firstName, this.lastName)\r\n    }\r\n}\r\n\r\nperson.fullName()\r\n```\r\n> 以上文中的英语语句和js code进行对比，来初步理解JavaScript中的this用法。其中*Yanina*和\r\n> *person*映射，*she* 和*this*映射。在英文语句中，*she*用来代替上下文中的*Yanina*,\r\n> *this*关键字是用来指代那个被当前函数（就是使用了 this 的函数）绑定的对象*person*。\r\n> *this*其实就是一个具有**调用当前函数的对象的值的变量**。\r\n\r\n## 全局作用域使用this 😉(非Node环境)\r\n```js\r\nvar firstName = \"Yanina\"\r\nvar lastName = \"Bu\"\r\nfunction fullName () {\r\n    console.log(this.firstName, this.lastName)\r\n}\r\n\r\nvar person = {\r\n    firstName: 'Mars',\r\n    lastName: 'Shi',\r\n    fullName: function () {\r\n        console.log(this.firstName, this.lastName)\r\n    }\r\n}\r\n\r\nfullName() // Yanina Bu\r\nthis.fullName() // Yanina Bu\r\nperson.fullName() // Mars Shi\r\n```\r\n> 以上code中，*firstName*, *lastName*和*fullName*都是定义在全局作用域的变量。全局定义的\r\n> 函数中，this指向*window*对象。但是`person.fullName()`中this的**上下文**为*person*\r\n> 对象，所以，这里的this指向*person*\r\n\r\n在下面这些情景中， this 关键字可能会变得十分难以理解。在示例中同时给出了解决有关 this 使用错误的方案。\r\n#### 1. 包含 this 的方法被当做回调函数时遇到的问题🤑\r\n\r\nerror:\r\n```js\r\nvar obj = {\r\n  getThisName () {\r\n    console.log(this.constructor.name)\r\n  }\r\n}\r\nsetTimeout(obj.getThisName, 1000)\r\n```\r\n> `obj.getThisName`作为*setTimeout*的回调函数，此时的*getThisName*函数执行的上下文为\r\n> *Timeout*对象（Browser中， `this` 指向 `Window` 对象），所以此时this指向的对象为*Timeout*对象。\r\n\r\ncorrect:\r\n```js\r\nvar obj = {\r\n  getThisName () {\r\n    console.log(this.constructor.name)\r\n  }\r\n}\r\nsetTimeout(obj.getThisName.bind(obj), 1000)\r\n```\r\n> 使用bind()方法显式的设置this的值。\r\n\r\n#### 2. this 出现在闭包内遇到的问题😧\r\n\r\nerror:\r\n```js\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    students: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        this.students.forEach(function (student) {\r\n            console.log(student, 'from', this.clazzName)\r\n        })\r\n    }\r\n}\r\n\r\nclazz.call()\r\n```\r\n> *forEach*中的匿名函数为*call*的内层函数，内层函数中不可访问外层函数的this变量\r\n\r\ncorrect:\r\n```js\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    students: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        var clazzObj = this\r\n        this.students.forEach(function (student) {\r\n            console.log(student, 'from', clazzObj.clazzName)\r\n        })\r\n    }\r\n}\r\n\r\nclazz.call()\r\n```\r\nor\r\n```js\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    students: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        this.students.forEach((student) => {\r\n            console.log(student, 'from', this.clazzName)\r\n        })\r\n    }\r\n}\r\n\r\nclazz.call()\r\n```\r\n> 方法一使用变量将this'转存'。方法二，使用*ES6*的箭头函数，箭头函数内部的this是词法作用域，\r\n> 由上下文确定，本例中的上下文是*clazz*\r\n\r\n#### 3. 把一个 this 方法 赋给一个变量时出现的问题😌\r\n\r\nerror:\r\n```js\r\nvar students = ['mars', 'yanina']\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    studesnts: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        this.students.forEach((student) => {\r\n            console.log(student)\r\n        })\r\n    }\r\n}\r\nvar callFromClass1 = clazz.call\r\ncallFromClass1()\r\n```\r\n> 此时`callFromClass1()`取的*studesnts*不是*clazz*中的属性，而是全局的*studesnts*，因为函\r\n> 数*callFromClass1*的执行上下文是全局。\r\n\r\ncorrect:\r\n```js\r\nvar callFromClass1 = clazz.call.bind(clazz)\r\ncallFromClass1()\r\n```\r\n> 使用`bind()`方法将*call*和*clazz*对象绑定起来，显式的设置*this*的值。\r\n\r\n#### 4. 当借用方法的时候 this 的值不正确的问题🙃\r\n\r\nerror:\r\n```js\r\nvar gameController = {\r\n\tscores: [20, 34, 55, 46, 77],\r\n\tavgScore: null,\r\n\tplayers: [\r\n\t\t{name: \"Tommy\", playerID: 987, age: 23},\r\n\t\t{name: \"Pau\", playerID: 87, age: 33}\r\n\t]\r\n}\r\nvar appController = {\r\n\tscores: [900, 845, 809, 950],\r\n\tavgScore: null,\r\n\tavg: function() {\r\n\t\tvar sumOfScores = this.scores.reduce(function(prev, cur, index, array) {\r\n\t\t\treturn prev + cur\r\n\t\t})\r\n\t\tthis.avgScore = sumOfScores / this.scores.length\r\n\t}\r\n}\r\ngameController.avgScore = appController.avg()\r\nconsole.log(gameController.avgScore)\r\nconsole.log(appController.avgScore)\r\n```\r\n> 在 avg 方法中的 this 不会指向 gameController 对象，而会指向 appController 对象，因\r\n> 为它是被 appController 对象所调用的。\r\n\r\ncorrect:\r\n```js\r\nappController.avg.apply(gameController, gameController.scores)\r\n```\r\n> gameController 对象借用了 appController 的 avg() 方法。在 appController.avg() 中\r\n> 的 this 的值会被设置成 gameController 对象，因为我们把 gameController 作为第一个参数\r\n> 传入了 apply() 方法中。传入 apply() 方法的第一个参数会被显式地设置为 this 的值\r\n",
      "data": {
        "title": "JavaScript : this",
        "date": "2020-03-19 21:33:12",
        "tags": [
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/javascript_this.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "javaScript-this"
    },
    {
      "content": "### **mongo[🍃](https://docs.mongodb.com/manual/reference/program/mongo/)**\r\n* run mongo shell with a connection string\r\n```shell\r\nmongo \"mongodb://<username>:<password>@<host>:<port>/<db name>\" <js file>\r\n```\r\n* run mongo shell with various command-line options\r\n```shell\r\nmongo -u <username> -p <password> --host <host> --port <port>  <js file>\r\n```\r\n\r\n---\r\n### **mongodump[🍀](https://docs.mongodb.com/manual/reference/program/mongodump/)**\r\n```shell\r\nmongodump -h <ip>:<port> -d <db name> -u <userName> -p <pwd> -c <collection> -o <dump dir>\r\n```\r\n*Also can run mongodump shell with --uri*\r\n```shell\r\nmongodump --uri \"mongodb://<username>:<password>@<host>:<port>/<db name>\" [additional options]\r\n```\r\n\r\n---\r\n### **mongorestore[🌴](https://docs.mongodb.com/manual/reference/program/mongorestore/)** \r\n```shell\r\nmongorestore [options] [<directory>/<BSON file>]\r\n```\r\n*Part of options is same as [mongodump](#mongodump)*\r\n\r\n---\r\n### **mongoexport[☘️](https://docs.mongodb.com/manual/reference/program/mongoexport/)**\r\n```shell\r\nmongoexport -u <username> -p <password> --host <host> --port <port> -d <db name>  -c <collection> --out <json/csv file>\r\n```\r\n*Also can run mongoexport shell with --uri*\r\n\r\n---\r\n### **mongoimport[🍂](https://docs.mongodb.com/manual/reference/program/mongoimport/)**\r\n```shell\r\nmongoimport -u <username> -p <password> --host <host> --port <port> -d <db name>  -c <collection> --file <json/csv file>\r\n```\r\n*Also can run mongoimport shell with --uri*",
      "data": {
        "title": "MongoDB: 基础命令",
        "date": "2020-03-17 17:31:51",
        "tags": [
          "MongoDB"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/mongodb_logo.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mongo-base-command"
    },
    {
      "content": "在了解 js 中的闭包概念之前，首先了解以下几个概念：\r\n\r\n- [立即执行函数](#立即执行函数)\r\n- [作用域以及变量](#作用域以及变量)\r\n\r\n### 立即执行函数🍑\r\n首先理解以下概念：函数声明，函数表达式，匿名函数。如下code：\r\n```js\r\nfunction fun () {\r\n    console.log(\"函数声明\")\r\n}\r\nvar f = function fun () {\r\n    console.log(\"函数表达式\")\r\n}\r\nfunction () {\r\n    console.log(\"匿名函数\")\r\n}\r\n```\r\n立即执行函数即为函数表达式在创建后立即执行。实现方式如下：\r\n```js\r\n(function (param) {\r\n    console.log(param) // 输出 1，使用()运算符\r\n} ) (1)\r\n\r\n(function (param) {\r\nconsole.log(param) // 输出 1，使用()运算符\r\n} (1) )\r\n\r\n[! || - || +]function (param) {\r\nconsole.log(param) // 输出 1 ，使用 ! 或 - 或 + 运算符\r\n} (1)\r\n```\r\n\r\n### 作用域以及变量🍔\r\nES5 只有全局作用域和函数作用域，全局作用域指的是script标签或者一个js文件。函数作用域指的是，函数被调用时，在内存中创建函数作用域，函数执行完毕后，该作用域被销毁，且函数每调用一次，就会创建一个新的函数作用域，相互独立。当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则会报错ReferenceError。\r\n```js\r\nvar param = '全局变量param'\r\nfunction func1 () {\r\n  var param1 = 'func1的局部变量param1'\r\n  function func2 () {\r\n    var param2 = 'func1的局部变量param2'\r\n    console.log(param2) // func1的局部变量param2\r\n    console.log(param) // 全局变量param\r\n  }\r\n  func2()\r\n  console.log(param) // 全局变量param\r\n  console.log(param1) // func1的局部变量param1\r\n  console.log(param2) // ReferenceError: param2 is not defined\r\n}\r\n\r\nfunc1()\r\n```\r\n在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量\r\n\r\n# 开始弄懂闭包🍖\r\n## 1. 什么是闭包？😮\r\n```js\r\n(function () {  // 立即执行函数\r\n    var localParam = \"局部变量\"\r\n    function func () {\r\n        console.log(localParam)\r\n    }\r\n})()\r\n\r\n闭包在 ES6 体现：\r\n{\r\n    let localParam = \"局部变量\"\r\n    function func () {\r\n        console.log(localParam)\r\n    }\r\n}\r\n```\r\n上面code中，立即执行函数中的三行代码: 一个局部变量，一个可以访问这个局部变量的函数，这两个条件的总和（或者叫做环境）就是闭包。\r\n\r\n## 2. 闭包的作用是什么？😜\r\n假如说，一个公司的员工的基础工资为1000💰，但是作为老板的你不希望其他leader随随便便就给手下的员工涨工资，需要经过你的审核。那么下面方案就符合你的要求：\r\n```js\r\n(function () {\r\n    var employeeSalary = 1000\r\n    function riseSalary (amount) {\r\n        console.log(\"老板审核完成，允许涨工资\")\r\n        employeeSalary += amount\r\n        return employeeSalary\r\n    }\r\n    globalThis.riseSalary = riseSalary\r\n})()\r\nconsole.log(globalThis.riseSalary(100))\r\n```\r\n如果想给员工涨工资，就必须调用`riseSalary()`函数，小leader就不能随随便便操作`employeeSalary`。\r\n其实我理解的闭包的作用就是，有那么一个变量，你不希望把它暴漏在全局作用域，从而让别人直接访问到。那么你会把这个变量声明为局部变量，但是局部变量别人就访问不到了。那么此时就需要使用闭包，提供一个访问器（函数），让使用者间接使用这个局部变量。\r\n\r\n## 3. 小结⏳\r\n闭包看起来不就是想让`var`命令声明的变量不可以在全局访问到吗？！😂那就用 ES6 的`let`和`const`来声明变量吧！\r\n最后发现一篇挺好的文章，丢个链接[👍](https://www.cnblogs.com/zhuzhenwei918/p/6131345.html)\r\n",
      "data": {
        "title": "JavaScript: 闭包",
        "date": "2020-03-17 15:28:44",
        "tags": [
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/javascript_feature.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "javascript-closure"
    },
    {
      "content": "# 1. var🍋\r\n\r\n`ES5` 只有全局作用域和函数作用域，没有块级作用域。\r\n\r\n```js\r\nlet arr1 = []\r\nfor (var i = 0; i < 2; i++) {\r\n    arr1[i] = function() {\r\n        console.log(i)\r\n    }\r\n}\r\narr1[1]() // 输出结果为2\r\n```\r\n上面code中，在`for`循环中，循环变量`i`使用`var`命令定义时，相当于全局有效。每次循环执行时，循环变量`i`的值都会被重新赋值所覆盖掉。函数体`{ console.log(i) }`不是立即执行，当循环结束时，`arr1[1]()`开始调用函数执行，此时`i`的值为2，所以控制台输出2。\r\n\r\n# 2. let🍉\r\n\r\nES6 中新增了`let`命令进行变量的定义，所定义的变量只在`let`命令所在的代码块内有效，`let`命令实际上为 JavaScript 新增了块级作用域。\r\n\r\n```js\r\nlet arr2 = []\r\nfor (let j = 0; j < 2; j++) {\r\n    arr2[j] = function() {\r\n        console.log(j)\r\n    }\r\n}\r\narr2[1]() // 输出结果为1\r\n```\r\n上面的code中，在`for`循环中，循环变量`j`使用`let`命令定义，这样变量`j`就不会被'泄露'到全局作用域中。每次循环都是`j`都是一个新的变量，且每次循环都是一个新的块作用域。当语句`arr2[1]()`执行时，所调用的函数体`console.log(j)`中的变量`j`为当次循环的新的块作用域中的变量`j`,值为1，所以控制台输出1。\r\n\r\n# 3. const🍅\r\nES6中新增了`const`命令，用来声明一个值不可以改变的常量，`const`除了所声明的变量的值不可以改变，用法和`let`命令几乎相同，但是推荐优先使用const。都只在当前块作用域有效，并检查当前块作用域形成暂时性死区。\r\n```js\r\nconst PI = 3.1415 // PI的值不可以被改变，声明并且初始化\r\nPI = 3 // TypeError: Assignment to constant variable.\r\n```\r\n\r\n`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于使用`const`命令声明的基本数据类型（`undefined、null、number、boolean、string`）值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（对象和数组等），只能保证变量所指向的内存地址不变（指针不变），但是内存里所保存的值是可以变化的。\r\n```js\r\nconst person = {\r\n    name: 'Mars'\r\n}\r\nperson.name = 'Yanina' // Yanina\r\nconsole.log(person.name)\r\nperson = {} // TypeError: Assignment to constant variable.\r\n```",
      "data": {
        "title": "ES6: JS变量的声明",
        "date": "2020-03-15 21:00:09",
        "tags": [
          "ES6",
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/javascript_variable_declaration.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "es6-variable-declaration"
    }
  ],
  "tags": [
    {
      "name": "Git",
      "slug": "RrsrpuDdn",
      "used": true
    },
    {
      "index": -1,
      "name": "Vue",
      "slug": "vue",
      "used": true
    },
    {
      "index": -1,
      "name": "NPM",
      "slug": "jKPki5ft6",
      "used": true
    },
    {
      "name": "Node",
      "slug": "2lKxFb2mgF",
      "used": true
    },
    {
      "name": "JavaScript",
      "slug": "OiN8CLTmo",
      "used": true
    },
    {
      "name": "Browser",
      "slug": "f60ELn4Qhf",
      "used": true
    },
    {
      "name": "Linux",
      "slug": "fdvmVrdrrC",
      "used": true
    },
    {
      "name": "MongoDB",
      "slug": "97WQkWtCw_",
      "used": true
    },
    {
      "name": "ES6",
      "slug": "rhbjFcFtXz",
      "used": true
    },
    {
      "index": -1,
      "name": "Java",
      "slug": "Java",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "🏠Home",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "📁Archives",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "🔖Tags",
      "openType": "Internal"
    },
    {
      "link": "/links",
      "name": "🔗Links",
      "openType": "Internal"
    }
  ]
}