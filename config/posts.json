{
  "posts": [
    {
      "content": "在了解 js 中的闭包概念之前，首先了解以下几个概念：\r\n\r\n- [立即执行函数](#立即执行函数)\r\n- [作用域以及变量](#作用域以及变量)\r\n\r\n### 立即执行函数🍑\r\n首先理解以下概念：函数声明，函数表达式，匿名函数。如下code：\r\n```\r\nfunction fun () {\r\n    console.log(\"函数声明\")\r\n}\r\nvar f = function fun () {\r\n    console.log(\"函数表达式\")\r\n}\r\nfunction () {\r\n    console.log(\"匿名函数\")\r\n}\r\n```\r\n立即执行函数即为函数表达式在创建后立即执行。实现方式如下：\r\n```\r\n(function (param) {\r\n    console.log(param) // 输出 1，使用()运算符\r\n} ) (1)\r\n\r\n(function (param) {\r\nconsole.log(param) // 输出 1，使用()运算符\r\n} (1) )\r\n\r\n[! || - || +]function (param) {\r\nconsole.log(param) // 输出 1 ，使用 ! 或 - 或 + 运算符\r\n} (1)\r\n```\r\n\r\n### 作用域以及变量🍔\r\nES5 只有全局作用域和函数作用域，全局作用域只的是script标签或者一个js文件。函数作用域指的是，函数被调用时，在内存中创建函数作用域，函数执行完毕后，该作用域被销毁，且函数每调用一次，就会创建一个新的函数作用域，相互独立。当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则会报错ReferenceError。\r\n```\r\nvar param = '全局变量param'\r\nfunction func1 () {\r\n  var param1 = 'func1的局部变量param1'\r\n  function func2 () {\r\n    var param2 = 'func1的局部变量param2'\r\n    console.log(param2) // func1的局部变量param2\r\n    console.log(param) // 全局变量param\r\n  }\r\n  func2()\r\n  console.log(param) // 全局变量param\r\n  console.log(param1) // func1的局部变量param1\r\n  console.log(param2) // ReferenceError: param2 is not defined\r\n}\r\n\r\nfunc1()\r\n```\r\n在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量\r\n\r\n# 开始弄懂闭包🍖\r\n[参考文档](https://zhuanlan.zhihu.com/p/22486908)\r\n\r\n\r\n",
      "data": {
        "title": "JavaScript: 闭包",
        "date": "2020-03-17 15:28:44",
        "tags": [
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "_Uh0ZoSNz"
    },
    {
      "content": "# 1. var🍋\r\n\r\n`ES5` 只有全局作用域和函数作用域，没有块级作用域。\r\n\r\n```\r\nlet arr1 = []\r\nfor (var i = 0; i < 2; i++) {\r\n    arr1[i] = function() {\r\n        console.log(i)\r\n    }\r\n}\r\narr1[1]() // 输出结果为2\r\n```\r\n上面code中，在`for`循环中，循环变量`i`使用`var`命令定义时，相当于全局有效。每次循环执行时，循环变量`i`的值都会被重新赋值所覆盖掉。函数体`{ console.log(i) }`不是立即执行，当循环结束时，`arr1[1]()`开始调用函数执行，此时`i`的值为2，所以控制台输出2。\r\n\r\n# 2. let🍉\r\n\r\nES6 中新增了`let`命令进行变量的定义，所定义的变量只在`let`命令所在的代码块内有效，`let`命令实际上为 JavaScript 新增了块级作用域。\r\n\r\n```\r\nlet arr2 = []\r\nfor (let j = 0; j < 2; j++) {\r\n    arr2[j] = function() {\r\n        console.log(j)\r\n    }\r\n}\r\narr2[1]() // 输出结果为1\r\n```\r\n上面的code中，在`for`循环中，循环变量`j`使用`let`命令定义，这样变量`j`就不会被'泄露'到全局作用域中。每次循环都是`j`都是一个新的变量，所以每次循环都是一个新的块作用域。当语句`arr2[1]()`执行时，所调用的函数体`console.log(j)`中的变量`j`为当次循环的新的块作用域中的变量`j`,值为1，所以控制台输出1。\r\n\r\n# 3. const🍅\r\nES6中新增了`const`命令，用来声明一个值不可以改变的常量，`const`除了所声明的变量的值不可以改变，用法和`let`命令几乎相同，都只在当前块作用域有效，并检查当前块作用域形成暂时性死区。\r\n```\r\nconst PI = 3.1415 // PI的值不可以被改变，声明并且初始化\r\nPI = 3 // TypeError: Assignment to constant variable.\r\n```\r\n\r\n`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于使用`const`命令声明的基本数据类型（`undefined、null、number、boolean、string`）值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（对象和数组等），只能保证变量所指向的内存地址不变（指针不变），但是内存里所保存的值是可以变化的。\r\n```\r\nconst person = {\r\n    name: 'Mars'\r\n}\r\nperson.name = 'Yanina' // Yanina\r\nconsole.log(person.name)\r\nperson = {} // TypeError: Assignment to constant variable.\r\n```",
      "data": {
        "title": "ES6: JS变量的声明",
        "date": "2020-03-15 21:00:09",
        "tags": [
          "ES6",
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "QG5Q6-9X0"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "JavaScript",
      "slug": "BjPiTG8OK",
      "used": true
    },
    {
      "index": -1,
      "name": "ES6",
      "slug": "es6",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    }
  ]
}