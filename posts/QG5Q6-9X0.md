---
title: 'ES6: JS变量的声明'
date: 2020-03-15 21:00:09
tags: [ES6]
published: true
hideInList: false
feature: 
isTop: false
---
# 1. var

`ES5` 只有全局作用域和函数作用域，没有块级作用域。

```
let arr1 = []
for (var i = 0; i < 2; i++) {
    arr1[i] = function() {
        console.log(i)
    }
}
arr1[1]() // 输出结果为2
```
上面code中，在`for`循环中，循环变量`i`使用`var`命令定义时，相当于全局有效。每次循环执行时，循环变量`i`的值都会被重新赋值所覆盖掉。函数体`{ console.log(i) }`不是立即执行，当循环结束时，`arr1[1]()`开始调用函数执行，此时`i`的值为2，所以控制台输出2。

# 2. let

`ES6`中新增了`let`命令进行变量的定义，所定义的变量只在`let`命令所在的代码块内有效，`let`命令实际上为 `JavaScript` 新增了块级作用域。

```
let arr2 = []
for (let j = 0; j < 2; j++) {
    arr2[j] = function() {
        console.log(j)
    }
}
arr2[1]() // 输出结果为1
```
上面的code中，在`for`循环中，循环变量`j`使用`let`命令定义，这样变量`j`就不会被'泄露'到全局作用域中。每次循环都是`j`都是一个新的变量，所以每次循环都是一个新的块作用域。当语句`arr2[1]()`执行时，所调用的函数体`console.log(j)`中的变量`j`为当次循环的新的块作用域中的变量`j`,值为1，所以控制台输出1。

# 3. const
`ES6`中新增了`const`命令，用来声明一个值不可以改变的常量，`const`除了所声明的变量的值不可以改变，用法和let命令几乎相同，都只在当前块作用域有效，并检查当前块作用域形成暂时性死区。
```
const PI = 3.1415 // PI的值不可以被改变，声明并且初始化
PI = 3 // TypeError: Assignment to constant variable.
```

const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于使用const命令声明的基本数据类型（undefined、null、number、boolean、string）值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（对象和数组等），只能保证变量所指向的内存地址不变（指针不变），但是内存里所保存的值是可以变化的。
```
const person = {
    name: 'Mars'
}
person.name = 'Yanina' // Yanina
console.log(person.name)
person = {} // TypeError: Assignment to constant variable.
```