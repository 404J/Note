{
  "posts": [
    {
      "content": "*记录下常用或者不常用，会用或者不会用的 Linux 文件操作命令*\r\n---\r\n#### 新建\r\n```shell\r\nmkdir <folderName> # 新建文件夹\r\ntouch <fileName> # 新建文件\r\nln -s <source> <dest> # 创建文件软连接(穿个软连接)\r\n```\r\n---\r\n#### 查看\r\n- 查看目录\r\n```shell\r\nll or ls -l # 显示目录文件详细信息\r\ndu -h <fileName or folderName> # 查看文件或者文件夹的大小\r\npwd # 显示当前路径\r\n```\r\n- 查看文件内容\r\n```shell\r\ncat <fileName> # 查看文件的全部内容\r\nhead -<headLine> <fileName> # 查看文件前几行的内容\r\ntail -n <startToTail> -f <fileName> # 显示文件后几行的内容\r\nmore <fileName> # 显示一屏文件内容。Space --> 下一屏内容; Enter --> 下一行内容; Q --> 退出\r\nless <fileName> # 类似于more，值得研究下\r\n🐖：more和less可以结合管道命令：history | more; ps -ef | more\r\n```\r\n- 查看文件状态\r\n```shell\r\nstat <fileName> # 查看文件详细信息\r\n```\r\n- 查看文件类型\r\n```shell\r\nfile <fileName> # 查看文件类型\r\n```\r\n---\r\n#### 删除\r\n```shell\r\nrm -f -i -r <fileName> # f --> force强制删除; i --> interactive交互式删除; r --> recursive递归删除文件夹\r\n```\r\n---\r\n#### 复制\r\n- 本地复制\r\n```shell\r\ncp -r <source> <dest> # r --> 复制文件夹\r\n```\r\n- 远程复制\r\n```shell\r\nscp -r <localFile> <remoteUserName>@<remoteIp>:<remoteFolder> # 本地复制到远程，r --> 复制文件夹\r\nscp -r <remoteUserName>@<remoteIp>:<remoteFolder> <localFile> # 远程复制到本地，r --> 复制文件夹\r\n```\r\n---\r\n#### 移到 or 重命名\r\n```shell\r\nmv <source> <dest> # 移动 or 重命名 文件或文件夹\r\n```\r\n---\r\n#### 归档 or 解压缩\r\n- 压缩\r\n```shell\r\ntar -cvf <dest.tar> <source> # 归档成*.tar包, c --> 建立档案; v --> 显示过程; f --> 使用档案名字，必填且最后一个参数\r\ntar -czvf <dest.tar.gz> <source> # 压缩成*.tar.gz文件, z --> 有gzip属性\r\ntar -cjvf <dest.tar.bz2> <source> # 压缩成*.tar.bz2文件, j --> 有bz2属性\r\nzip <dest.zip> <source> # 压缩成*.zip文件\r\n```\r\n- 解压\r\n```shell\r\ntar -xvf <dest.tar> # 展开*.tar包, x --> 解压\r\ntar -xzvf <dest.tar.gz> # 解压*.tar.gz文件\r\ntar -xjvf <dest.tar.gz> # 解压*.tar.bz2文件\r\nunzip <dest.zip> # 解压*.zip文件\r\n```\r\n> 🐖：[tar vs zip vs gz](https:#itsfoss.com/tar-vs-zip-vs-gz/)\r\n> ---\r\n#### 查找\r\n```shell\r\nfind <targetFolders> -name <targetName> -type <b/d/c/p/l/f> # type -->块设备、目录、字符设备、管道、符号链接、普通文件\r\nlocate <targetName>\r\nwhereis <targetName>\r\n```\r\n",
      "data": {
        "title": "Linux 命令之文件操作",
        "date": "2020-04-02 09:03:34",
        "tags": [
          "Linux"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/hannah-joshua-46T6nVjRc2w-unsplash.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "eb1SrSwLN"
    },
    {
      "content": "**谨以此篇blog记录server的mongoDB被洗空😖~~~**\r\n\r\n### 1. admin db创建超级管理员用户\r\n- 首先进入MongoDB shell\r\n```shell\r\nmongo\r\n```\r\n- 此时默认进入的test数据库，切换到admin数据库。关于admin数据库在mongoDB中的作用，\r\nstackoverflow上的一位网友讲的挺清楚，在此引用一下：*The main purpose of this admin database is to store system collections and user authentication and authorization data, which includes the administrator and user's usernames, passwords, and roles. Access is limited to only to administrators, who have the ability to create, update, and delete users and assign roles.*\r\n```js\r\nuse admin\r\n```\r\n- 创建Administrator\r\n```js\r\ndb.createUser({\r\n    user: <username>,\r\n    pwd: <password>,\r\n    roles: [{\r\n        role: <role>, db: <targetDB> // role一般指定为\"userAdminAnyDatabase\"\r\n    }]\r\n})  \r\n```\r\n> 以下为mongoDB内置的role\r\n\r\n| 分类                          | role(角色) | 简要说明 |\r\n| ----------------------------- | ---------- | -------- |\r\n| 数据库用户角色(DB User Roles) |    `read` `readWrite`        |  为某个数据库创建一个用户, 分配该数据库的读写权力        |\r\n| 数据库管理员角色(DB Admin Roles) | `dbAdmin` `dbOwner` `userAdmin` | 拥有创建数据库, 和创建用户的权力 |\r\n| 集群管理角色(Culster Administration Roles) | `clusterAdmin` `clusterManager` `clusterMonitor` `hostManager` | 管理员组, 针对整个系统进行管理 |\r\n| 备份还原角色(Backup and Restoration Roles) | `backup` `restore` | 备份数据库, 还原数据库 |\r\n| 所有数据库角色(All-Database Roles) | `readAnyDatabase` `readWriteAnyDatabase` `userAdminAnyDatabase` `dbAdminAnyDatabase` | 拥有对admin操作的权限 |\r\n| Superuser Roles(超级管理员) | `root` `dbOwner` `userAdmin` `userAdminAnyDatabase` | 这几个角色角色提供了任何数据任何用户的任何权限的能力，拥有这个角色的用户可以在任何数据库上定义它们自己的权限 |\r\n\r\n### 2. 重启mongo服务，开启认证\r\n- 停止服务\r\n```shell\r\nservice mongodb stop\r\n```\r\n- 修改配置文件\r\n```shell\r\nwhereis mongodb.conf // 查找配置文件\r\nauth = true // 配置文件mongodb.conf 去掉 auth = true 前面的注释\r\n```\r\n- 重启服务\r\n```shell\r\nservice mongodb start\r\nor\r\nmongod -f mongodb.conf\r\n```\r\n\r\n### 3. 认证方式登录mongo\r\n- 登录\r\n```js\r\nmongo\r\nuse admin\r\ndb.auth(<userName>, <password>)\r\nshow users // 查看用户\r\n```\r\n\r\n### 4. 创建指定db 用户\r\n- 认证登录admin后，切换至指定的db, 以管理员身份创建其他用户\r\n```js\r\nuse <targetDB>\r\ndb.createUser({\r\n    user: <username>,\r\n    pwd: <password>,\r\n    roles: [{\r\n        role: <role>, db: <targetDB> // role一般指定为\"readWrite\"\r\n    }]\r\n})\r\nshow users // 可以通过 _id确定用户所指定的数据库\r\n```\r\n\r\n### 5. 修改用户密码及删除用户\r\n- 首先以管理员身份登录admin，然后进行修改一般用户密码操作\r\n```js\r\nuse <targetDB> // 切换到待修改用户所在的db, 否则 user note found error\r\ndb.changeUserPassword(<userName>, <password>)\r\n```\r\n- 删除一般用户操作\r\n```js\r\nuse <targetDB> // 切换到待删除用户所在的db, 否则 user note found error\r\ndb.dropUser(<userName>)\r\n```",
      "data": {
        "title": "Mongodb 用户管理",
        "date": "2020-03-28 13:14:14",
        "tags": [
          "MongoDB"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/mongo-db-blog.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "5AnbX_s7H"
    },
    {
      "content": "**Yanina 👧 is very beautiful, and she is also very slim!**\r\n```js\r\nvar person = {\r\n    firstName: 'Mars',\r\n    lastName: 'Shi',\r\n    fullName: function () {\r\n        console.log(this.firstName, this.lastName)\r\n    }\r\n}\r\n\r\nperson.fullName()\r\n```\r\n> 以上文中的英语语句和js code进行对比，来初步理解JavaScript中的this用法。其中*Yanina*和\r\n> *person*映射，*she* 和*this*映射。在英文语句中，*she*用来代替上下文中的*Yanina*,\r\n> *this*关键字是用来指代那个被当前函数（就是使用了 this 的函数）绑定的对象*person*。\r\n> *this*其实就是一个具有调用当前函数的对象的值的变量。\r\n\r\n## 全局作用域使用this 😉(非Node环境)\r\n```js\r\nvar firstName = \"Yanina\"\r\nvar lastName = \"Bu\"\r\nfunction fullName () {\r\n    console.log(this.firstName, this.lastName)\r\n}\r\n\r\nvar person = {\r\n    firstName: 'Mars',\r\n    lastName: 'Shi',\r\n    fullName: function () {\r\n        console.log(this.firstName, this.lastName)\r\n    }\r\n}\r\n\r\nfullName() // Yanina Bu\r\nthis.fullName() // Yanina Bu\r\nperson.fullName() // Mars Shi\r\n```\r\n> 以上code中，*firstName*, *lastName*和*fullName*都是定义在全局作用域的变量。全局定义的\r\n> 函数中，this指向*window*对象。但是`person.fullName()`中this的**上下文**为*person*\r\n> 对象，所以，this指向*person*\r\n\r\n在下面这些情景中， this 关键字可能会变得十分难以理解。在示例中同时给出了解决有关 this 使用错误的方案。\r\n#### 1. 包含 this 的方法被当做回调函数时遇到的问题🤑\r\n\r\nerror:\r\n```js\r\nvar person = {\r\n    firstName: 'Mars',\r\n    lastName: 'Shi',\r\n    fullName: function () {\r\n        console.log(this.firstName, this.lastName)\r\n    }\r\n}\r\nsetTimeout(person.fullName, 1000)\r\n```\r\n> `person.fullName`作为*setTimeout*的回调函数，此时的*fullName*函数执行的上下文为\r\n> *Timeout*对象，所以此时this指向的对象为*Timeout*对象。\r\n\r\ncorrect:\r\n```js\r\nvar person = {\r\n    firstName: 'Mars',\r\n    lastName: 'Shi',\r\n    fullName: function () {\r\n        console.log(this)\r\n        console.log(this.firstName, this.lastName)\r\n    }\r\n}\r\nsetTimeout(person.fullName.bind(person), 1000)\r\n```\r\n> 使用bind()方法显式的设置this的值。\r\n\r\n#### 2. this 出现在闭包内遇到的问题😧\r\n\r\nerror:\r\n```js\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    students: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        this.students.forEach(function (student) {\r\n            console.log(student, 'from', this.clazzName)\r\n        })\r\n    }\r\n}\r\n\r\nclazz.call()\r\n```\r\n> *forEach*中的匿名函数为*call*的内层函数，内层函数中不可访问外层函数的this变量\r\n\r\ncorrect:\r\n```js\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    students: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        var clazzObj = this\r\n        this.students.forEach(function (student) {\r\n            console.log(student, 'from', clazzObj.clazzName)\r\n        })\r\n    }\r\n}\r\n\r\nclazz.call()\r\n```\r\nor\r\n```js\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    students: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        this.students.forEach((student) => {\r\n            console.log(student, 'from', this.clazzName)\r\n        })\r\n    }\r\n}\r\n\r\nclazz.call()\r\n```\r\n> 方法一使用变量将this'转存'。方法二，使用*ES6*的箭头函数，箭头函数内部的this是词法作用域，\r\n> 由上下文确定，本例中的上下文是*clazz*\r\n\r\n#### 3. 把一个 this 方法 赋给一个变量时出现的问题😌\r\n\r\nerror:\r\n```js\r\nvar students = ['mars', 'yanina']\r\nvar clazz = {\r\n    clazzName: 'class No.1',\r\n    studesnts: [\r\n        'Mars', 'Yanina'\r\n    ],\r\n    call: function () {\r\n        this.students.forEach((student) => {\r\n            console.log(student)\r\n        })\r\n    }\r\n}\r\nvar callFromClass1 = clazz.call\r\ncallFromClass1()\r\n```\r\n> 此时`callFromClass1()`取的*studesnts*不是*clazz*中的属性，而是全局的*clazz*，因为函\r\n> 数*callFromClass1*的执行上下文是全局。\r\n\r\ncorrect:\r\n```js\r\nvar callFromClass1 = clazz.call.bind(clazz)\r\ncallFromClass1()\r\n```\r\n> 使用`bind()`方法将*call*和*clazz*对象绑定起来，显式的设置*this*的值。\r\n\r\n#### 4. 当借用方法的时候 this 的值不正确的问题🙃\r\n\r\nerror:\r\n```js\r\nvar gameController = {\r\n\tscores: [20, 34, 55, 46, 77],\r\n\tavgScore: null,\r\n\tplayers: [\r\n\t\t{name: \"Tommy\", playerID: 987, age: 23},\r\n\t\t{name: \"Pau\", playerID: 87, age: 33}\r\n\t]\r\n}\r\nvar appController = {\r\n\tscores: [900, 845, 809, 950],\r\n\tavgScore: null,\r\n\tavg: function() {\r\n\t\tvar sumOfScores = this.scores.reduce(function(prev, cur, index, array) {\r\n\t\t\treturn prev + cur\r\n\t\t})\r\n\t\tthis.avgScore = sumOfScores / this.scores.length\r\n\t}\r\n}\r\ngameController.avgScore = appController.avg()\r\nconsole.log(gameController.avgScore)\r\nconsole.log(appController.avgScore)\r\n```\r\n> 在 avg 方法中的 this 不会指向 gameController 对象，而会指向 appController 对象，因\r\n> 为它是被 appController 对象所调用的。\r\n\r\ncorrect:\r\n```js\r\nappController.avg.apply(gameController, gameController.scores)\r\n```\r\n> gameController 对象借用了 appController 的 avg() 方法。在 appController.avg() 中\r\n> 的 this 的值会被设置成 gameController 对象，因为我们把 gameController 作为第一个参数\r\n> 传入了 apply() 方法中。传入 apply() 方法的第一个参数会被显式地设置为 this 的值\r\n",
      "data": {
        "title": "JavaScript : this",
        "date": "2020-03-19 21:33:12",
        "tags": [
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/shahadat-rahman-gnyA8vd3Otc-unsplash.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "G0jEltNXf"
    },
    {
      "content": "### **mongo[🍃](https://docs.mongodb.com/manual/reference/program/mongo/)**\r\n* run mongo shell with a connection string\r\n```shell\r\nmongo \"mongodb://<username>:<password>@<host>:<port>/<db name>\" <js file>\r\n```\r\n* run mongo shell with various command-line options\r\n```shell\r\nmongo -u <username> -p <password> --host <host> --port <port>  <js file>\r\n```\r\n\r\n---\r\n### **mongodump[🍀](https://docs.mongodb.com/manual/reference/program/mongodump/)**\r\n```shell\r\nmongodump -h <ip>:<port> -d <db name> -u <userName> -p <pwd> -c <collection> -o <dump dir>\r\n```\r\n*Also can run mongodump shell with --uri*\r\n```shell\r\nmongodump --uri \"mongodb://<username>:<password>@<host>:<port>/<db name>\" [additional options]\r\n```\r\n\r\n---\r\n### **mongorestore[🌴](https://docs.mongodb.com/manual/reference/program/mongorestore/)** \r\n```shell\r\nmongorestore [options] [<directory>/<BSON file>]\r\n```\r\n*Part of options is same as [mongodump](#mongodump)*\r\n\r\n---\r\n### **mongoexport[☘️](https://docs.mongodb.com/manual/reference/program/mongoexport/)**\r\n```shell\r\nmongoexport -u <username> -p <password> --host <host> --port <port> -d <db name>  -c <collection> --out <json/csv file>\r\n```\r\n*Also can run mongoexport shell with --uri*\r\n\r\n---\r\n### **mongoimport[🍂](https://docs.mongodb.com/manual/reference/program/mongoimport/)**\r\n```shell\r\nmongoimport -u <username> -p <password> --host <host> --port <port> -d <db name>  -c <collection> --file <json/csv file>\r\n```\r\n*Also can run mongoimport shell with --uri*",
      "data": {
        "title": "MongoDB: 基础命令",
        "date": "2020-03-17 17:31:51",
        "tags": [
          "MongoDB"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/image_1.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Co9D62eqS"
    },
    {
      "content": "在了解 js 中的闭包概念之前，首先了解以下几个概念：\r\n\r\n- [立即执行函数](#立即执行函数)\r\n- [作用域以及变量](#作用域以及变量)\r\n\r\n### 立即执行函数🍑\r\n首先理解以下概念：函数声明，函数表达式，匿名函数。如下code：\r\n```js\r\nfunction fun () {\r\n    console.log(\"函数声明\")\r\n}\r\nvar f = function fun () {\r\n    console.log(\"函数表达式\")\r\n}\r\nfunction () {\r\n    console.log(\"匿名函数\")\r\n}\r\n```\r\n立即执行函数即为函数表达式在创建后立即执行。实现方式如下：\r\n```js\r\n(function (param) {\r\n    console.log(param) // 输出 1，使用()运算符\r\n} ) (1)\r\n\r\n(function (param) {\r\nconsole.log(param) // 输出 1，使用()运算符\r\n} (1) )\r\n\r\n[! || - || +]function (param) {\r\nconsole.log(param) // 输出 1 ，使用 ! 或 - 或 + 运算符\r\n} (1)\r\n```\r\n\r\n### 作用域以及变量🍔\r\nES5 只有全局作用域和函数作用域，全局作用域指的是script标签或者一个js文件。函数作用域指的是，函数被调用时，在内存中创建函数作用域，函数执行完毕后，该作用域被销毁，且函数每调用一次，就会创建一个新的函数作用域，相互独立。当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则会报错ReferenceError。\r\n```js\r\nvar param = '全局变量param'\r\nfunction func1 () {\r\n  var param1 = 'func1的局部变量param1'\r\n  function func2 () {\r\n    var param2 = 'func1的局部变量param2'\r\n    console.log(param2) // func1的局部变量param2\r\n    console.log(param) // 全局变量param\r\n  }\r\n  func2()\r\n  console.log(param) // 全局变量param\r\n  console.log(param1) // func1的局部变量param1\r\n  console.log(param2) // ReferenceError: param2 is not defined\r\n}\r\n\r\nfunc1()\r\n```\r\n在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量\r\n\r\n# 开始弄懂闭包🍖\r\n## 1. 什么是闭包？😮\r\n```js\r\n(function () {  // 立即执行函数\r\n    var localParam = \"局部变量\"\r\n    function func () {\r\n        console.log(localParam)\r\n    }\r\n})()\r\n\r\n闭包在 ES6 体现：\r\n{\r\n    let localParam = \"局部变量\"\r\n    function func () {\r\n        console.log(localParam)\r\n    }\r\n}\r\n```\r\n上面code中，立即执行函数中的三行代码: 一个局部变量，一个可以访问这个局部变量的函数，这两个条件的总和（或者叫做环境）就是闭包。\r\n\r\n## 2. 闭包的作用是什么？😜\r\n假如说，一个公司的员工的基础工资为1000💰，但是作为老板的你不希望其他leader随随便便就给手下的员工涨工资，需要经过你的审核。那么下面方案就符合你的要求：\r\n```js\r\n(function () {\r\n    var employeeSalary = 1000\r\n    function riseSalary (amount) {\r\n        console.log(\"老板审核完成，允许涨工资\")\r\n        employeeSalary += amount\r\n        return employeeSalary\r\n    }\r\n    globalThis.riseSalary = riseSalary\r\n})()\r\nconsole.log(globalThis.riseSalary(100))\r\n```\r\n如果想给员工涨工资，就必须调用`riseSalary()`函数，小leader就不能随随便便操作`employeeSalary`。\r\n其实我理解的闭包的作用就是，有那么一个变量，你不希望把它暴漏在全局作用域，从而让别人直接访问到。那么你会把这个变量声明为局部变量，但是局部变量别人就访问不到了。那么此时就需要使用闭包，提供一个访问器（函数），让使用者间接使用这个局部变量。\r\n\r\n## 3. 小结⏳\r\n闭包看起来不就是想让`var`命令声明的变量不可以在全局访问到吗？！😂那就用 ES6 的`let`和`const`来声明变量吧！\r\n最后发现一篇挺好的文章，丢个链接[👍](https://www.cnblogs.com/zhuzhenwei918/p/6131345.html)\r\n",
      "data": {
        "title": "JavaScript: 闭包",
        "date": "2020-03-17 15:28:44",
        "tags": [
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/shahadat-rahman-BfrQnKBulYQ-unsplash.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "_Uh0ZoSNz"
    },
    {
      "content": "# 1. var🍋\r\n\r\n`ES5` 只有全局作用域和函数作用域，没有块级作用域。\r\n\r\n```js\r\nlet arr1 = []\r\nfor (var i = 0; i < 2; i++) {\r\n    arr1[i] = function() {\r\n        console.log(i)\r\n    }\r\n}\r\narr1[1]() // 输出结果为2\r\n```\r\n上面code中，在`for`循环中，循环变量`i`使用`var`命令定义时，相当于全局有效。每次循环执行时，循环变量`i`的值都会被重新赋值所覆盖掉。函数体`{ console.log(i) }`不是立即执行，当循环结束时，`arr1[1]()`开始调用函数执行，此时`i`的值为2，所以控制台输出2。\r\n\r\n# 2. let🍉\r\n\r\nES6 中新增了`let`命令进行变量的定义，所定义的变量只在`let`命令所在的代码块内有效，`let`命令实际上为 JavaScript 新增了块级作用域。\r\n\r\n```js\r\nlet arr2 = []\r\nfor (let j = 0; j < 2; j++) {\r\n    arr2[j] = function() {\r\n        console.log(j)\r\n    }\r\n}\r\narr2[1]() // 输出结果为1\r\n```\r\n上面的code中，在`for`循环中，循环变量`j`使用`let`命令定义，这样变量`j`就不会被'泄露'到全局作用域中。每次循环都是`j`都是一个新的变量，所以每次循环都是一个新的块作用域。当语句`arr2[1]()`执行时，所调用的函数体`console.log(j)`中的变量`j`为当次循环的新的块作用域中的变量`j`,值为1，所以控制台输出1。\r\n\r\n# 3. const🍅\r\nES6中新增了`const`命令，用来声明一个值不可以改变的常量，`const`除了所声明的变量的值不可以改变，用法和`let`命令几乎相同，都只在当前块作用域有效，并检查当前块作用域形成暂时性死区。\r\n```js\r\nconst PI = 3.1415 // PI的值不可以被改变，声明并且初始化\r\nPI = 3 // TypeError: Assignment to constant variable.\r\n```\r\n\r\n`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于使用`const`命令声明的基本数据类型（`undefined、null、number、boolean、string`）值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（对象和数组等），只能保证变量所指向的内存地址不变（指针不变），但是内存里所保存的值是可以变化的。\r\n```js\r\nconst person = {\r\n    name: 'Mars'\r\n}\r\nperson.name = 'Yanina' // Yanina\r\nconsole.log(person.name)\r\nperson = {} // TypeError: Assignment to constant variable.\r\n```",
      "data": {
        "title": "ES6: JS变量的声明",
        "date": "2020-03-15 21:00:09",
        "tags": [
          "ES6",
          "JavaScript"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://404j-images.test.upcdn.net/coverImage/dwblog-ecmascriptseries-1.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "QG5Q6-9X0"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "Linux",
      "slug": "oTKW8mqTA",
      "used": true
    },
    {
      "name": "MongoDB",
      "slug": "q4H-QJGk1",
      "used": true
    },
    {
      "index": -1,
      "name": "JavaScript",
      "slug": "BjPiTG8OK",
      "used": true
    },
    {
      "index": -1,
      "name": "ES6",
      "slug": "es6",
      "used": true
    },
    {
      "name": "Git",
      "slug": "D-3t-2pwn",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "🏠Home",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "📁Archives",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "🔖Tags",
      "openType": "Internal"
    },
    {
      "link": "/links",
      "name": "🔗Links",
      "openType": "Internal"
    }
  ]
}